[
  {
    "report_id": "Commercial_Lending/CLO_ActivePortfolio_Officer_Report",
    "name": "CLO_ActivePortfolio_Officer_Report",
    "business_line": "Commercial_Lending",
    "purpose": "Main Entry Point",
    "frequency": "manual",
    "has_email": true,
    "data_sources": [
      "OSIBANK",
      "sqlalchemy",
      "OSIEXTN"
    ],
    "version": ")\n    else:\n        BASE_PATH = Path(",
    "functions": [
      "main"
    ],
    "needs_config": true,
    "analysis": {
      "main": {
        "docstring": "Main Entry Point",
        "imports": [
          "from pathlib",
          "from typing",
          "from datetime",
          "import pandas",
          "import src.fetch_data",
          "import src.core_transform",
          "import cdutils.pkey_sqlite",
          "import cdutils.hhnbr",
          "import src.output_to_excel",
          "import cdutils.loans.calculations",
          "import cdutils.inactive_date",
          "from src._version"
        ],
        "database_queries": [
          "Complete!"
        ],
        "output_patterns": [
          ".to_excel(OUTPUT_PATH, sheet_name='Sheet1', index=False)",
          ".to_excel(writer, sheet_name=sheet_name, index=False)",
          "OUTPUT_PATH = BASE_PATH / Path(output_string)",
          "OUTPUT_PATH, sheet_name='Sheet1', index=False)",
          "OUTPUT_PATH, engine='xlsxwriter', datetime_format='mm/dd/yyyy') as writer:",
          "OUTPUT_PATH = BASE_PATH / Path",
          "ExcelWriter"
        ],
        "email_patterns": [
          "email_out(",
          "distribution.",
          "@bcsbmail.com",
          "@bcsbmail.com",
          "@bcsbmail.com",
          "@bcsbmail.com",
          "recipients =",
          "recipients ="
        ],
        "path_patterns": [
          "r'\\\\00-DA1\\Home\\Share\\\\Data & Analytics Initiatives\\\\Project Management\\\\Commercial_Lending\\\\CLO_ActivePortfolio_Officer_Report\\\\Production'",
          "Path(r'\\\\00-DA1\\Home\\Share\\\\Data & Analytics Initiatives\\\\Project Management\\\\Commercial_Lending\\\\CLO_ActivePortfolio_Officer_Report\\\\Production')",
          "Path('.')",
          "Path(output_string)",
          "BASE_PATH =",
          "BASE_PATH =",
          "production_flag",
          "production_flag",
          "production_flag"
        ],
        "version": ")\n    else:\n        BASE_PATH = Path(",
        "functions": [
          "main"
        ],
        "schedule_hints": [],
        "data_sources": [],
        "file_operations": []
      },
      "fetch_data": {
        "queries": [
          "text(f\"\"\"\n    SELECT\n        a.NOTENEXTRATECHANGEDATE,\n        a.EFFDATE,\n        a.ACCTNBR,\n        a.OWNERSORTNAME,\n        a.PRODUCT,\n        a.NOTEOPENAMT,\n        a.RATETYPCD,\n        a.MJACCTTYPCD,\n        a.CURRMIACCTTYPCD,\n        a.CURRACCTSTATCD,\n        a.NOTEINTRATE,\n        a.BOOKBALANCE,\n        a.NOTEBAL,\n        a.CONTRACTDATE,\n        a.DATEMAT,\n        a.TAXRPTFORORGNBR,\n        a.TAXRPTFORPERSNBR,\n        a.LOANOFFICER\n    FROM\n        OSIBANK.WH_ACCTCOMMON a\n    WHERE\n        (a.CURRACCTSTATCD IN ('ACT')",
          "text(f\"\"\"\n    SELECT\n        a.ACCTNBR,\n        a.ORIGDATE,\n        a.CURRTERM,\n        a.LOANIDX,\n        a.RCF,\n        a.AVAILBALAMT,\n        a.FDICCATDESC,\n        a.ORIGBAL,\n        a.LOANLIMITYN\n    FROM\n        OSIBANK.WH_LOANS a\n    \"\"\")",
          "text(f\"\"\"\n    SELECT\n        a.ACCTNBR,\n        a.CREDITLIMITAMT,\n        a.ORIGINTRATE,\n        a.MARGINFIXED,\n        a.FDICCATCD,\n        a.AMORTTERM,\n        a.TOTALPCTSOLD,\n        a.COBAL,\n        a.CREDLIMITCLATRESAMT,\n        a.RISKRATINGCD\n    FROM\n        OSIBANK.WH_ACCTLOAN a\n    \"\"\")",
          "text(\"\"\"\n    SELECT\n        a.ACCTNBR,\n        a.HOUSEHOLDNBR,\n        a.DATELASTMAINT\n    FROM\n        OSIEXTN.HOUSEHLDACCT a\n    \"\"\")",
          "text(\"\"\"\n    SELECT\n        a.ACCTNBR,\n        a.ACCTUSERFIELDCDDESC,\n        a.ACCTUSERFIELDVALUE\n    FROM\n        OSIBANK.WH_ACCTUSERFIELDS a\n    WHERE\n        (a.ACCTUSERFIELDCDDESC IN ('SBA Guarantee Expiration Date')"
        ],
        "tables": [
          "OSIBANK",
          "sqlalchemy",
          "OSIEXTN"
        ],
        "databases": []
      }
    }
  },
  {
    "report_id": "Commercial_Lending/Deposit Dash",
    "name": "Deposit Dash",
    "business_line": "Commercial_Lending",
    "purpose": "Main Entry: Deposit Dash\nDeveloped by CD",
    "frequency": "daily",
    "has_email": true,
    "data_sources": [],
    "version": ")\n    main()\n    print(",
    "functions": [
      "main"
    ],
    "needs_config": true,
    "analysis": {
      "main": {
        "docstring": "Main Entry: Deposit Dash\nDeveloped by CD",
        "imports": [
          "from pathlib",
          "import datetime",
          "import pandas",
          "from src._version",
          "import cdutils.distribution",
          "import src.output_to_excel"
        ],
        "database_queries": [],
        "output_patterns": [
          ".to_excel(OUTPUT_PATH, sheet_name='Sheet1', index=False)",
          "OUTPUT_PATH = Path(f'./output/DepositDash_{current_date}.xlsx')",
          "OUTPUT_PATH, sheet_name='Sheet1', index=False)",
          "OUTPUT_PATH = Path"
        ],
        "email_patterns": [
          "email_out(",
          "distribution.",
          "@bcsbmail.com",
          "@bcsbmail.com",
          "@bcsbmail.com",
          "@bcsbmail.com",
          "@bcsbmail.com",
          "recipients =",
          "recipients =",
          "recipients =",
          "recipients ="
        ],
        "path_patterns": [
          "r'\\\\00-da1\\Home\\Share\\Line of Business_Shared Services\\Commercial Lending\\Deposits\\DailyDeposit\\DailyDeposit.xlsx'",
          "Path(f'./output/DepositDash_{current_date}.xlsx')"
        ],
        "version": ")\n    main()\n    print(",
        "functions": [
          "main"
        ],
        "schedule_hints": [
          "daily",
          "monthly"
        ],
        "data_sources": [],
        "file_operations": [
          "read_excel"
        ]
      },
      "fetch_data": {}
    }
  },
  {
    "report_id": "Commercial_Lending/Status Page",
    "name": "Status Page",
    "business_line": "Commercial_Lending",
    "purpose": "Main Entry Point",
    "frequency": "daily",
    "has_email": true,
    "data_sources": [
      "OSIBANK",
      "sqlalchemy",
      "OSIEXTN"
    ],
    "version": ")\n    else:\n        BASE_PATH = Path(",
    "functions": [
      "main"
    ],
    "needs_config": false,
    "analysis": {
      "main": {
        "docstring": "Main Entry Point",
        "imports": [
          "from pathlib",
          "from typing",
          "import argparse",
          "from datetime",
          "import pandas",
          "import src.fetch_data",
          "import src.core_transform",
          "import src.output_to_excel",
          "from src._version",
          "import cdutils.pkey_sqlite",
          "import cdutils.daily_deposit_staging",
          "import cdutils.string_regex",
          "import cdutils.distribution"
        ],
        "database_queries": [
          "Complete!"
        ],
        "output_patterns": [
          "OUTPUT_PATH = PARENT_DIR / \"output\" / file_name",
          "OUTPUT_PATH.parent.mkdir(parents=True, exist_ok=True)",
          "output_path = OUTPUT_PATH,",
          "output_path = OUTPUT_PATH"
        ],
        "email_patterns": [
          "email_out(",
          "distribution.",
          "@bcsbmail.com",
          "@bcsbmail.com",
          "@bcsbmail.com",
          "@bcsbmail.com",
          "@bcsbmail.com",
          "recipients =",
          "recipients ="
        ],
        "path_patterns": [
          "r'\\\\00-DA1\\Home\\Share\\Line of Business_Shared Services\\Commercial_Lending\\Status Page'",
          "Path(r'\\\\00-DA1\\Home\\Share\\Line of Business_Shared Services\\Commercial_Lending\\Status Page')",
          "Path('.')",
          "Path(__file__)",
          "BASE_PATH =",
          "BASE_PATH =",
          "production_flag",
          "production_flag",
          "production_flag"
        ],
        "version": ")\n    else:\n        BASE_PATH = Path(",
        "functions": [
          "main"
        ],
        "schedule_hints": [
          "daily"
        ],
        "data_sources": [],
        "file_operations": []
      },
      "fetch_data": {
        "queries": [
          "text(f\"\"\"\n    SELECT\n        a.EFFDATE,\n        a.ACCTNBR,\n        a.OWNERSORTNAME,\n        a.PRODUCT,\n        a.NOTEOPENAMT,\n        a.RATETYPCD,\n        a.MJACCTTYPCD,\n        a.CURRMIACCTTYPCD,\n        a.CURRACCTSTATCD,\n        a.NOTEINTRATE,\n        a.BOOKBALANCE,\n        a.NOTEBAL,\n        a.CONTRACTDATE,\n        a.DATEMAT,\n        a.TAXRPTFORORGNBR,\n        a.TAXRPTFORPERSNBR\n    FROM\n        OSIBANK.WH_ACCTCOMMON a\n    WHERE\n        (a.CURRACCTSTATCD IN ('ACT','NPFM','DORM')",
          "text(f\"\"\"\n    SELECT\n        a.ACCTNBR,\n        a.ORIGDATE,\n        a.CURRTERM,\n        a.LOANIDX,\n        a.RCF,\n        a.AVAILBALAMT,\n        a.FDICCATDESC,\n        a.ORIGBAL,\n        a.LOANLIMITYN\n    FROM\n        OSIBANK.WH_LOANS a\n    \"\"\")",
          "text(f\"\"\"\n    SELECT\n        a.ACCTNBR,\n        a.CREDITLIMITAMT,\n        a.ORIGINTRATE,\n        a.MARGINFIXED,\n        a.FDICCATCD,\n        a.AMORTTERM,\n        a.TOTALPCTSOLD,\n        a.COBAL,\n        a.CREDLIMITCLATRESAMT\n    FROM\n        OSIBANK.WH_ACCTLOAN a\n    \"\"\")",
          "text(\"\"\"\n    SELECT\n        a.PERSNBR,\n        a.TAXID\n    FROM\n        OSIBANK.VIEWPERSTAXID a\n    \"\"\")",
          "text(\"\"\"\n    SELECT\n        a.ORGNBR,\n        a.TAXID\n    FROM\n        OSIBANK.VIEWORGTAXID a\n    \"\"\")",
          "text(\"\"\"\n    SELECT\n        a.ACCTNBR,\n        a.HOUSEHOLDNBR,\n        a.DATELASTMAINT\n    FROM\n        OSIEXTN.HOUSEHLDACCT a\n    \"\"\")",
          "text(\"\"\"\n    SELECT\n        a.HOUSEHOLDNBR,\n        a.HOUSEHOLDTITLE,\n        a.HEADOFHOUSENBR,\n        a.HEADOFHOUSETYP\n    FROM\n        OSIEXTN.HOUSEHLD a\n    \"\"\")",
          "text(\"\"\"\n    SELECT\n        a.ACCTNBR,\n        a.INACTIVEDATE\n    FROM\n        OSIBANK.ACCTLOANLIMITHIST a\n    \"\"\")",
          "text(\"\"\"\n    SELECT\n        a.PERSNBR,\n        a.PERSNAME\n    FROM\n        OSIBANK.WH_PERS a\n    \"\"\")",
          "text(\"\"\"\n    SELECT\n        a.ORGNBR,\n        a.ORGNAME\n    FROM\n        OSIBANK.WH_ORG a\n    \"\"\")",
          "text(\"\"\"\n    SELECT\n        *\n    FROM \n        OSIBANK.WH_ALLROLES a\n    \"\"\")"
        ],
        "tables": [
          "OSIBANK",
          "sqlalchemy",
          "OSIEXTN"
        ],
        "databases": []
      }
    }
  },
  {
    "report_id": "Commercial_Lending/YTD_Business_Deposits",
    "name": "YTD_Business_Deposits",
    "business_line": "Commercial_Lending",
    "purpose": "Business Deposit Account: Custom Date Range ",
    "frequency": "manual",
    "has_email": true,
    "data_sources": [
      "sqlalchemy",
      "COCCDM"
    ],
    "version": ")\n    else:\n        BASE_PATH = Path(",
    "functions": [
      "main"
    ],
    "needs_config": true,
    "analysis": {
      "main": {
        "docstring": "Business Deposit Account: Custom Date Range ",
        "imports": [
          "from pathlib",
          "from typing",
          "import pandas",
          "import src.fetch_data",
          "import src.cdutils.input_cleansing",
          "from src._version",
          "import src.output_to_excel",
          "import cdutils.distribution"
        ],
        "database_queries": [],
        "output_patterns": [
          ".to_excel(OUTPUT_PATH, sheet_name='Sheet1', engine='openpyxl', index=False)",
          "OUTPUT_PATH = Path('./output/business_deposit_report_2025_YTD.xlsx')",
          "OUTPUT_PATH, sheet_name='Sheet1', engine='openpyxl', index=False)",
          "OUTPUT_PATH = Path"
        ],
        "email_patterns": [
          "email_out(",
          "distribution.",
          "@bcsbmail.com",
          "@bcsbmail.com",
          "@bcsbmail.com",
          "@bcsbmail.com",
          "@bcsbmail.com",
          "@bcsbmail.com",
          "recipients =",
          "recipients =",
          "recipients =",
          "recipients ="
        ],
        "path_patterns": [
          "r'\\\\00-DA1\\Home\\Share\\Line of Business_Shared Services'",
          "Path(r'\\\\00-DA1\\Home\\Share\\Line of Business_Shared Services')",
          "Path('.')",
          "Path('./output/business_deposit_report_2025_YTD.xlsx')",
          "BASE_PATH =",
          "BASE_PATH =",
          "production_flag",
          "production_flag",
          "production_flag"
        ],
        "version": ")\n    else:\n        BASE_PATH = Path(",
        "functions": [
          "main"
        ],
        "schedule_hints": [],
        "data_sources": [],
        "file_operations": []
      },
      "fetch_data": {
        "queries": [
          "text(\"\"\"\n    SELECT \n        a.ACCTNBR, \n        a.EFFDATE, \n        a.MJACCTTYPCD, \n        a.PRODUCT, \n        a.CURRMIACCTTYPCD, \n        a.BOOKBALANCE, \n        a.ACCTOFFICER, \n        a.OWNERSORTNAME, \n        a.CURRACCTSTATCD, \n        a.CONTRACTDATE, \n        a.BRANCHNAME,\n        a.NOTEINTRATE,\n        a.PRIMARYOWNERCITY,\n        a.PRIMARYOWNERSTATE\n    FROM \n        COCCDM.WH_ACCTCOMMON a\n    WHERE \n        a.CURRACCTSTATCD IN ('ACT','DORM')",
          "text(\"\"\"\n    SELECT \n        a.ACCTNBR, \n        a.EFFDATE, \n        a.MJACCTTYPCD, \n        a.PRODUCT, \n        a.CURRMIACCTTYPCD, \n        a.BOOKBALANCE, \n        a.ACCTOFFICER, \n        a.OWNERSORTNAME, \n        a.CURRACCTSTATCD, \n        a.CONTRACTDATE, \n        a.BRANCHNAME,\n        a.NOTEINTRATE,\n        a.PRIMARYOWNERCITY,\n        a.PRIMARYOWNERSTATE\n    FROM \n        COCCDM.WH_ACCTCOMMON a\n    WHERE \n        a.CURRACCTSTATCD IN ('ACT','DORM')",
          "text(\"\"\"\n    SELECT \n        a.ACCTNBR, \n        a.EFFDATE, \n        a.MJACCTTYPCD, \n        a.PRODUCT, \n        a.CURRMIACCTTYPCD, \n        a.BOOKBALANCE, \n        a.ACCTOFFICER, \n        a.OWNERSORTNAME, \n        a.CURRACCTSTATCD, \n        a.CONTRACTDATE, \n        a.BRANCHNAME,\n        a.NOTEINTRATE,\n        a.PRIMARYOWNERCITY,\n        a.PRIMARYOWNERSTATE\n    FROM \n        COCCDM.WH_ACCTCOMMON_ME a\n    WHERE \n        a.CURRACCTSTATCD IN ('ACT','DORM')"
        ],
        "tables": [
          "sqlalchemy",
          "COCCDM"
        ],
        "databases": []
      }
    }
  },
  {
    "report_id": "Commercial_Lending/Deposit Deep Dive",
    "name": "Deposit Deep Dive",
    "business_line": "Commercial_Lending",
    "purpose": "Deposit Deep Dive: Main Entry",
    "frequency": "monthly",
    "has_email": true,
    "data_sources": [
      "sqlalchemy",
      "COCCDM"
    ],
    "version": ")\n    else:\n        BASE_PATH = Path(",
    "functions": [
      "main"
    ],
    "needs_config": true,
    "analysis": {
      "main": {
        "docstring": "Deposit Deep Dive: Main Entry",
        "imports": [
          "from datetime",
          "import json",
          "import os",
          "import time",
          "from pathlib",
          "import pandas",
          "import numpy",
          "import src.fetch_data",
          "import cdutils.distribution",
          "import src.output_to_excel",
          "from src._version"
        ],
        "database_queries": [],
        "output_patterns": [
          ".to_excel(writer, sheet_name='Summary', index=False)",
          ".to_excel(writer, sheet_name=officer, index=False)",
          "OUTPUT_PATH = BASE_PATH / Path(f\"./output/deposit_deep_dive_{me_date_no_slash}.xlsx\")",
          "OUTPUT_PATH, engine='openpyxl') as writer:",
          "OUTPUT_PATH = BASE_PATH / Path",
          "ExcelWriter"
        ],
        "email_patterns": [
          "email_out(",
          "distribution.",
          "@bcsbmail.com",
          "@bcsbmail.com",
          "@bcsbmail.com",
          "@bcsbmail.com",
          "@bcsbmail.com",
          "recipients =",
          "recipients =",
          "recipients =",
          "recipients ="
        ],
        "path_patterns": [
          "r'\\\\00-DA1\\Home\\Share\\Line of Business_Shared Services\\Retail Banking\\New Business Checking\\Production'",
          "Path(r'\\\\00-DA1\\Home\\Share\\Line of Business_Shared Services\\Retail Banking\\New Business Checking\\Production')",
          "Path('.')",
          "Path(f\"./output/deposit_deep_dive_{me_date_no_slash}.xlsx\")",
          "BASE_PATH =",
          "BASE_PATH =",
          "production_flag",
          "production_flag",
          "production_flag"
        ],
        "version": ")\n    else:\n        BASE_PATH = Path(",
        "functions": [
          "main"
        ],
        "schedule_hints": [
          "monthly"
        ],
        "data_sources": [],
        "file_operations": []
      },
      "fetch_data": {
        "queries": [
          "text(\"\"\"\n    SELECT DISTINCT\n        a.EFFDATE\n    FROM \n        COCCDM.WH_ACCTCOMMON a\n    WHERE\n        MONTHENDYN = 'Y'\n    ORDER BY EFFDATE DESC\n    \"\"\")",
          "text(f\"\"\"\n    SELECT \n        a.ACCTNBR,\n        a.OWNERNAME,\n        a.PRODUCT,\n        a.LOANOFFICER,\n        a.ACCTOFFICER,\n        a.EFFDATE, \n        a.MJACCTTYPCD, \n        a.CURRMIACCTTYPCD,\n        a.NOTEBAL,\n        a.BOOKBALANCE,\n        a.NOTEINTRATE,\n        a.CURRACCTSTATCD, \n        a.CONTRACTDATE,\n        a.DATEMAT,\n        a.TAXRPTFORORGNBR,\n        a.TAXRPTFORPERSNBR\n    FROM \n        COCCDM.WH_ACCTCOMMON a\n    WHERE\n        a.EFFDATE = TO_DATE('{recent_me}', 'yyyy-mm-dd hh24:mi:ss')",
          "text(f\"\"\"\n    SELECT \n        a.ACCTNBR,\n        a.OWNERNAME,\n        a.PRODUCT,\n        a.LOANOFFICER,\n        a.ACCTOFFICER,\n        a.EFFDATE, \n        a.MJACCTTYPCD, \n        a.CURRMIACCTTYPCD,\n        a.NOTEBAL,\n        a.BOOKBALANCE,\n        a.NOTEINTRATE,\n        a.CURRACCTSTATCD, \n        a.CONTRACTDATE,\n        a.DATEMAT,\n        a.TAXRPTFORORGNBR,\n        a.TAXRPTFORPERSNBR\n    FROM \n        COCCDM.WH_ACCTCOMMON a\n    WHERE\n        a.EFFDATE = TO_DATE('{prior_me}', 'yyyy-mm-dd hh24:mi:ss')"
        ],
        "tables": [
          "sqlalchemy",
          "COCCDM"
        ],
        "databases": []
      }
    }
  },
  {
    "report_id": "Commercial_Lending/Business_Concentration_of_Deposits",
    "name": "Business_Concentration_of_Deposits",
    "business_line": "Commercial_Lending",
    "purpose": "Main Entry Point",
    "frequency": "daily",
    "has_email": false,
    "data_sources": [],
    "version": ")\n    else:\n        BASE_PATH = Path(",
    "functions": [
      "main"
    ],
    "needs_config": true,
    "analysis": {
      "main": {
        "docstring": "Main Entry Point",
        "imports": [
          "from pathlib",
          "import pandas",
          "import cdutils.pkey_sqlite",
          "import cdutils.filtering",
          "import cdutils.input_cleansing",
          "import cdutils.cmo_append",
          "import src.add_fields",
          "import src.core_transform",
          "import src.output_to_excel",
          "from src._version",
          "import src.output_to_excel_multiple_sheets"
        ],
        "database_queries": [
          "Complete!",
          "Select High Yield\n    ]\n\n    # Filter to only business deposit accounts\n    data = cdutils.filtering.filter_to_business_deposits(data, minors)\n\n\n    # Add CMO\n    data = cdutils.cmo_append.append_cmo(data)\n\n\n    data_schema = {\n        'noteintrate': float\n    }\n\n    data = cdutils.input_cleansing.enforce_schema(data, data_schema).copy()\n\n\n\n\n    # %%\n    # Exclude BCSB internal accounts\n    data = data[~data['ownersortname'].str.contains('BRISTOL COUNTY SAVINGS', case=False, na=False)].copy()\n\n    # %%\n    data\n\n    # %%\n\n\n\n\n\n\n\n    # %%\n    # %%\n    ASSETS_PATH = Path('./assets')\n\n    files = [f for f in ASSETS_PATH.iterdir() if f.is_file()]\n\n    assert len(files) == 1, f\"Expected exactly 1 file in {ASSETS_PATH}, found {len(files)}.\"\n\n    file = files[0]\n    assert file.suffix == '.csv', f\"Expected an excel file\"\n\n    xaa_data = pd.read_csv(file, header=3)\n\n    # %%\n    # xaa_data.info()\n\n    #\n\n    # %%\n\n\n\n\n    # # %%\n    # xaa_data['Analyzed Charges (Pre-ECR)'] = xaa_data['Analyzed Charges (Pre-ECR)'].str.replace('[\\$,]','',regex=True)\n    # xaa_data['Combined Result for Settlement Period (Post-ECR + Fee-Based Total)'] = xaa_data['Combined Result for Settlement Period (Post-ECR + Fee-Based Total)'].str.replace('[\\$,]','',regex=True)\n\n    # %%\n    xaa_schema = {\n        'Analyzed Charges':'float',\n        'Combined Result for Settlement Period':'float',\n        'Earnings Credit Rate':'float',\n        'Debit Account Number':'str'\n    }\n    xaa_data = cdutils.input_cleansing.enforce_schema(xaa_data, xaa_schema)\n\n\n\n    # %%\n\n    from datetime import datetime, timedelta\n\n    def create_account_summary_alternative(xaa_data, date_col='cycle_date'):\n        # Ensure date column is datetime\n        xaa_data = xaa_data.copy()\n        xaa_data[date_col] = pd.to_datetime(xaa_data[date_col])\n        # Calculate cutoff date for 12 months\n        max_date = xaa_data[date_col].max()\n        cutoff_date = max_date - timedelta(days=365)\n        # Add ranking column to identify latest month per account\n        xaa_data['date_rank'] = (xaa_data\n                                .groupby('Debit Account Number')[date_col]\n                                .rank(method='dense', ascending=False))\n        # Create flags for latest month and trailing 12 months\n        xaa_data['is_latest_month'] = xaa_data['date_rank'] == 1\n        xaa_data['is_trailing_12m'] = xaa_data[date_col] >= cutoff_date\n        # Aggregate using conditional sums\n        summary = (xaa_data\n                .groupby('Debit Account Number')\n                .agg({\n                    # Latest month aggregations\n                    'Analyzed Charges': [\n                        lambda x: x[xaa_data.loc[x.index, 'is_latest_month']].sum(),\n                        lambda x: x[xaa_data.loc[x.index, 'is_trailing_12m']].sum(),\n                    ],\n                    'Combined Result for Settlement Period': [\n                        lambda x: x[xaa_data.loc[x.index, 'is_latest_month']].sum(),\n                        lambda x: x[xaa_data.loc[x.index, 'is_trailing_12m']].sum()\n                    ],\n                    'Earnings Credit Rate': [\n                        lambda x: x[xaa_data.loc[x.index, 'is_latest_month']].mean(),\n                        lambda x: x[xaa_data.loc[x.index, 'is_trailing_12m']].mean()\n                    ],\n                    'Primary Officer Name': 'first',\n                    'Secondary Officer Name': 'first',\n                    'Treasury Officer Name': 'first'\n                })\n                .reset_index())\n        # Flatten column names\n        summary.columns = [\n            'Debit Account Number',\n            'Latest_Month_Analyzed_Charges',\n            'Trailing_12M_Analyzed_Charges',\n            'Latest_Month_Combined_Result',\n            'Trailing_12M_Combined_Result',\n            'Latest_Month_ECR',\n            'Trailing_12M_Avg_ECR',\n            'Primary_Officer_Name_XAA',\n            'Secondary_Officer_Name_XAA',\n            'Treasury_Officer_Name_XAA'\n        ]\n        # Reorder columns\n        column_order = [\n            'Debit Account Number',\n            'Latest_Month_Analyzed_Charges',\n            'Latest_Month_Combined_Result',\n            'Trailing_12M_Analyzed_Charges',\n            'Trailing_12M_Combined_Result',\n            'Latest_Month_ECR',\n            'Trailing_12M_Avg_ECR',\n            'Primary_Officer_Name_XAA',\n            'Secondary_Officer_Name_XAA',        \n            'Treasury_Officer_Name_XAA'\n        ]\n        return summary[column_order]\n\n\n    # %%\n    summarized_xaa = create_account_summary_alternative(xaa_data, date_col='Cycle End Date')\n\n    # %%\n    summarized_xaa_schema = {\n        'Primary_Officer_Name_XAA':'str',\n        'Secondary_Officer_Name_XAA':'str',        \n        'Treasury_Officer_Name_XAA':'str'\n    }\n    summarized_xaa = cdutils.input_cleansing.enforce_schema(summarized_xaa, summarized_xaa_schema)\n\n    # %%\n\n    # %%\n    summarized_xaa = summarized_xaa.rename(columns={\n        'Debit Account Number':'acctnbr',\n\n    }).copy()\n\n    assert summarized_xaa['acctnbr'].is_unique, \"Duplicates\"\n\n\n\n\n    # %%\n\n\n\n\n\n    # %%\n    # %%\n    merged_data = pd.merge(data, summarized_xaa, on='acctnbr', how='left')\n\n    # %%\n\n    fill_na_column_list = [\n        'Latest_Month_Analyzed_Charges',\n        'Latest_Month_Combined_Result',\n        'Trailing_12M_Analyzed_Charges',\n        'Trailing_12M_Combined_Result',\n        'Latest_Month_ECR',\n        'Trailing_12M_Avg_ECR',\n    ]\n    for item in fill_na_column_list:\n        merged_data[item] = merged_data[item].fillna(0)\n\n\n    # Sort descending order of notebal\n    merged_data = merged_data.sort_values(by='notebal', ascending=False)\n\n    # %%\n    # merged_data.info()\n\n    # %%\n    merged_data\n\n\n\n    # %%\n    # This part doesn't work. Look at noteinrate, gets weird\n\n    # %%\n    formatted_data = src.core_transform.main_pipeline(merged_data)\n\n    # %%\n    formatted_data\n\n    # %%\n    formatted_data = formatted_data.rename(columns={\n        'portfolio_key':'Portfolio Key',\n        'product':'Product',\n        '3Mo_AvgBal':'3Mo Avg Bal',\n        'TTM_AvgBal':'TTM Avg Bal',\n        'TTM_DAYS_OVERDRAWN':'TTM Days Overdrawn',\n        'TTM_NSF_COUNT':'TTM NSF Count'\n    }).copy()\n\n\n    # %%\n    # Create summary sheet\n\n    summary_data = formatted_data[~(formatted_data['Portfolio Key'] == \"\") & (formatted_data['Acct No.'] == \"\")].copy()\n    summary_data = summary_data[[\n        'Portfolio Key',\n        'Borrower Name',\n        'Account Officer',\n        'Cash Management Officer',\n        'Current Balance',\n        'Interest Rate',\n        '3Mo Avg Bal',\n        'TTM Avg Bal',\n        'Year Ago Balance',\n        'TTM Days Overdrawn',\n        'TTM NSF Count',\n        'Current Mo Analyzed Fees (Pre-ECR)',\n        'Current Mo Net Analyzed Fees (Post-ECR)',\n        'TTM Analyzed Fees (Pre-ECR)',\n        'TTM Net Analyzed Fees (Post-ECR)',\n        'Current ECR'\n    ]].copy()\n\n\n    # %%\n    # %%\n    # Output to excel (raw data)\n    # BASE_PATH = Path('.')\n    OUTPUT_PATH = BASE_PATH / Path('./output/business_deposits_concentration_with_xaa.xlsx')\n    with pd.ExcelWriter(OUTPUT_PATH, engine=\"openpyxl\") as writer:\n        formatted_data.to_excel(writer, sheet_name='Relationship Detail', index=False)\n        summary_data.to_excel(writer, sheet_name='Relationship Summary', index=False)\n        merged_data.to_excel(writer, sheet_name='Unformatted', index=False)\n\n\n    # Format excel\n    src.output_to_excel_multiple_sheets.format_excel_file(OUTPUT_PATH)\n\nif __name__ == '__main__':\n    print(f\"Starting [{__version__}]\")\n    # main(production_flag=True)\n    main()\n    print(\"Complete!\")\n\n\n\n# %%\n\n\n\n"
        ],
        "output_patterns": [
          ".to_excel(writer, sheet_name='Relationship Detail', index=False)",
          ".to_excel(writer, sheet_name='Relationship Summary', index=False)",
          ".to_excel(writer, sheet_name='Unformatted', index=False)",
          "OUTPUT_PATH = BASE_PATH / Path('./output/business_deposits_concentration_with_xaa.xlsx')",
          "OUTPUT_PATH, engine=\"openpyxl\") as writer:",
          "OUTPUT_PATH = BASE_PATH / Path",
          "ExcelWriter"
        ],
        "email_patterns": [],
        "path_patterns": [
          "r'\\\\00-DA1\\Home\\Share\\Line of Business_Shared Services'",
          "r\"\\\\00-da1\\Home\\Share\\Data & Analytics Initiatives\\Project Management\\Data_Analytics\\Daily_Deposit_Update\\Production\\output\\DailyDeposit_staging.xlsx\"",
          "Path(r'\\\\00-DA1\\Home\\Share\\Line of Business_Shared Services')",
          "Path('.')",
          "Path(r\"\\\\00-da1\\Home\\Share\\Data & Analytics Initiatives\\Project Management\\Data_Analytics\\Daily_Deposit_Update\\Production\\output\\DailyDeposit_staging.xlsx\")",
          "Path('./assets')",
          "Path('.')",
          "Path('./output/business_deposits_concentration_with_xaa.xlsx')",
          "BASE_PATH =",
          "BASE_PATH =",
          "BASE_PATH =",
          "production_flag",
          "production_flag",
          "production_flag"
        ],
        "version": ")\n    else:\n        BASE_PATH = Path(",
        "functions": [
          "main"
        ],
        "schedule_hints": [
          "daily"
        ],
        "data_sources": [],
        "file_operations": [
          "read_excel",
          "read_csv"
        ]
      },
      "fetch_data": {}
    }
  },
  {
    "report_id": "Commercial_Lending/DepositPocketPricing",
    "name": "DepositPocketPricing",
    "business_line": "Commercial_Lending",
    "purpose": "Analyzes deposit account data and relationships",
    "frequency": "manual",
    "has_email": false,
    "data_sources": [
      "OSIBANK",
      "sqlalchemy",
      "OSIEXTN"
    ],
    "version": ")\n    # main(production_flag=True)\n    main()\n    print(",
    "functions": [
      "main"
    ],
    "needs_config": true,
    "analysis": {
      "main": {
        "docstring": null,
        "imports": [
          "from pathlib",
          "import pandas",
          "from src._version"
        ],
        "database_queries": [],
        "output_patterns": [
          ".to_excel(OUTPUT_PATH, index=False)",
          "OUTPUT_PATH = Path('./output/deposit_pocket_pricing_raw.xlsx')",
          "OUTPUT_PATH, index=False)",
          "OUTPUT_PATH = Path"
        ],
        "email_patterns": [],
        "path_patterns": [
          "Path(\"./assets/DepositPocketPricing.xlsx\")",
          "Path('./output/deposit_pocket_pricing_raw.xlsx')",
          "production_flag"
        ],
        "version": ")\n    # main(production_flag=True)\n    main()\n    print(",
        "functions": [
          "main"
        ],
        "schedule_hints": [],
        "data_sources": [],
        "file_operations": [
          "read_excel"
        ]
      },
      "fetch_data": {
        "queries": [
          "text(f\"\"\"\n    SELECT\n        a.EFFDATE,\n        a.ACCTNBR,\n        a.OWNERSORTNAME,\n        a.PRODUCT,\n        a.NOTEOPENAMT,\n        a.RATETYPCD,\n        a.MJACCTTYPCD,\n        a.CURRMIACCTTYPCD,\n        a.CURRACCTSTATCD,\n        a.NOTEINTRATE,\n        a.BOOKBALANCE,\n        a.NOTEBAL,\n        a.CONTRACTDATE,\n        a.DATEMAT,\n        a.TAXRPTFORORGNBR,\n        a.TAXRPTFORPERSNBR\n    FROM\n        OSIBANK.WH_ACCTCOMMON a\n    WHERE\n        (a.CURRACCTSTATCD IN ('ACT')",
          "text(f\"\"\"\n    SELECT\n        a.ACCTNBR,\n        a.ORIGDATE,\n        a.CURRTERM,\n        a.LOANIDX,\n        a.RCF,\n        a.AVAILBALAMT,\n        a.FDICCATDESC,\n        a.ORIGBAL,\n        a.LOANLIMITYN\n    FROM\n        OSIBANK.WH_LOANS a\n    \"\"\")",
          "text(f\"\"\"\n    SELECT\n        a.ACCTNBR,\n        a.CREDITLIMITAMT,\n        a.ORIGINTRATE,\n        a.MARGINFIXED,\n        a.FDICCATCD,\n        a.AMORTTERM,\n        a.TOTALPCTSOLD,\n        a.COBAL,\n        a.CREDLIMITCLATRESAMT\n    FROM\n        OSIBANK.WH_ACCTLOAN a\n    \"\"\")",
          "text(\"\"\"\n    SELECT\n        a.ACCTNBR,\n        a.HOUSEHOLDNBR,\n        a.DATELASTMAINT\n    FROM\n        OSIEXTN.HOUSEHLDACCT a\n    \"\"\")"
        ],
        "tables": [
          "OSIBANK",
          "sqlalchemy",
          "OSIEXTN"
        ],
        "databases": []
      }
    }
  },
  {
    "report_id": "Retail/small_business_partnership_ma",
    "name": "small_business_partnership_ma",
    "business_line": "Retail",
    "purpose": "Main Entry Point",
    "frequency": "manual",
    "has_email": true,
    "data_sources": [
      "OSIBANK",
      "sqlalchemy",
      "OSIEXTN"
    ],
    "version": ")\n    else:\n        BASE_PATH = Path(",
    "functions": [
      "main"
    ],
    "needs_config": true,
    "analysis": {
      "main": {
        "docstring": "Main Entry Point",
        "imports": [
          "from pathlib",
          "from typing",
          "from datetime",
          "import pandas",
          "import src.fetch_data",
          "import src.core_transform",
          "import cdutils.pkey_sqlite",
          "import cdutils.hhnbr",
          "import src.output_to_excel",
          "import cdutils.loans.calculations",
          "from src._version"
        ],
        "database_queries": [
          "Complete!"
        ],
        "output_patterns": [
          ".to_excel(OUTPUT_PATH, sheet_name='Sheet1', index=False)",
          "OUTPUT_PATH = BASE_PATH / Path('./output/standard_report.xlsx')",
          "OUTPUT_PATH, sheet_name='Sheet1', index=False)",
          "OUTPUT_PATH = BASE_PATH / Path"
        ],
        "email_patterns": [
          "email_out(",
          "distribution.",
          "@bcsbmail.com",
          "@bcsbmail.com",
          "@bcsbmail.com",
          "@bcsbmail.com",
          "recipients =",
          "recipients ="
        ],
        "path_patterns": [
          "r'\\\\00-DA1\\Home\\Share\\Line of Business_Shared Services'",
          "Path(r'\\\\00-DA1\\Home\\Share\\Line of Business_Shared Services')",
          "Path('.')",
          "Path('./output/standard_report.xlsx')",
          "BASE_PATH =",
          "BASE_PATH =",
          "production_flag",
          "production_flag",
          "production_flag"
        ],
        "version": ")\n    else:\n        BASE_PATH = Path(",
        "functions": [
          "main"
        ],
        "schedule_hints": [],
        "data_sources": [],
        "file_operations": []
      },
      "fetch_data": {
        "queries": [
          "text(f\"\"\"\n    SELECT\n        a.EFFDATE,\n        a.ACCTNBR,\n        a.OWNERSORTNAME,\n        a.PRODUCT,\n        a.NOTEOPENAMT,\n        a.RATETYPCD,\n        a.MJACCTTYPCD,\n        a.CURRMIACCTTYPCD,\n        a.CURRACCTSTATCD,\n        a.NOTEINTRATE,\n        a.BOOKBALANCE,\n        a.NOTEBAL,\n        a.CONTRACTDATE,\n        a.DATEMAT,\n        a.TAXRPTFORORGNBR,\n        a.TAXRPTFORPERSNBR,\n        a.LOANOFFICER,\n        a.ACCTOFFICER\n    FROM\n        OSIBANK.WH_ACCTCOMMON a\n    WHERE\n        (a.CURRACCTSTATCD IN ('ACT','NPFM','DORM')",
          "text(f\"\"\"\n    SELECT\n        a.ACCTNBR,\n        a.ORIGDATE,\n        a.CURRTERM,\n        a.LOANIDX,\n        a.RCF,\n        a.AVAILBALAMT,\n        a.FDICCATDESC,\n        a.ORIGBAL,\n        a.LOANLIMITYN\n    FROM\n        OSIBANK.WH_LOANS a\n    \"\"\")",
          "text(f\"\"\"\n    SELECT\n        a.ACCTNBR,\n        a.CREDITLIMITAMT,\n        a.ORIGINTRATE,\n        a.MARGINFIXED,\n        a.FDICCATCD,\n        a.AMORTTERM,\n        a.TOTALPCTSOLD,\n        a.COBAL,\n        a.CREDLIMITCLATRESAMT,\n        a.RISKRATINGCD\n    FROM\n        OSIBANK.WH_ACCTLOAN a\n    \"\"\")",
          "text(\"\"\"\n    SELECT\n        a.ACCTNBR,\n        a.HOUSEHOLDNBR,\n        a.DATELASTMAINT\n    FROM\n        OSIEXTN.HOUSEHLDACCT a\n    \"\"\")",
          "text(\"\"\"\n    SELECT\n        *\n    FROM\n        OSIBANK.WH_PERS a\n    \"\"\")"
        ],
        "tables": [
          "OSIBANK",
          "sqlalchemy",
          "OSIEXTN"
        ],
        "databases": []
      }
    }
  },
  {
    "report_id": "Retail/NewLoanReport_Francine",
    "name": "NewLoanReport_Francine",
    "business_line": "Retail",
    "purpose": "Main Entry Point",
    "frequency": "weekly",
    "has_email": true,
    "data_sources": [],
    "version": ")\n    else:\n        BASE_PATH = Path(",
    "functions": [
      "main"
    ],
    "needs_config": true,
    "analysis": {
      "main": {
        "docstring": "Main Entry Point",
        "imports": [
          "from pathlib",
          "from datetime",
          "import pandas",
          "import src.cdutils.database.fdic_recon",
          "import src.cdutils.database.generic_query",
          "import src.core_transform",
          "import src.distribution",
          "import src.output_to_excel",
          "from src._version",
          "import src.output_to_excel_multiple_sheets"
        ],
        "database_queries": [
          "Complete!"
        ],
        "output_patterns": [
          ".to_excel(writer, sheet_name='Sheet1', index=False)",
          "OUTPUT_PATH = file_path / file_name",
          "OUTPUT_PATH, mode='w', engine='openpyxl') as writer:",
          "OUTPUT_PATH = file_path",
          "ExcelWriter"
        ],
        "email_patterns": [
          "email_out(",
          "distribution.",
          "@bcsbmail.com",
          "@bcsbmail.com",
          "@bcsbmail.com",
          "recipients =",
          "recipients ="
        ],
        "path_patterns": [
          "r'\\\\00-DA1\\Home\\Share\\Line of Business_Shared Services'",
          "Path(r'\\\\00-DA1\\Home\\Share\\Line of Business_Shared Services')",
          "Path('.')",
          "Path('./Output')",
          "BASE_PATH =",
          "BASE_PATH =",
          "production_flag",
          "production_flag",
          "production_flag"
        ],
        "version": ")\n    else:\n        BASE_PATH = Path(",
        "functions": [
          "main"
        ],
        "schedule_hints": [
          "weekly"
        ],
        "data_sources": [],
        "file_operations": []
      },
      "fetch_data": {}
    }
  },
  {
    "report_id": "Retail/New_Business_Checking",
    "name": "New_Business_Checking",
    "business_line": "Retail",
    "purpose": "New Business Checking\nDeveloped by CD\n[v1.0.5-prod] ",
    "frequency": "manual",
    "has_email": false,
    "data_sources": [],
    "version": ")\n    else:\n        BASE_PATH = Path(",
    "functions": [
      "main"
    ],
    "needs_config": true,
    "analysis": {
      "main": {
        "docstring": "New Business Checking\nDeveloped by CD\n[v1.0.5-prod] ",
        "imports": [
          "from pathlib",
          "import pandas",
          "import src.cdutils.database",
          "from src._version"
        ],
        "database_queries": [],
        "output_patterns": [
          ".to_excel(FILE_PATH, engine='openpyxl', index=False)"
        ],
        "email_patterns": [],
        "path_patterns": [
          "r'\\\\00-DA1\\Home\\Share\\Line of Business_Shared Services\\Retail Banking\\New Business Checking\\Production'",
          "Path(r'\\\\00-DA1\\Home\\Share\\Line of Business_Shared Services\\Retail Banking\\New Business Checking\\Production')",
          "Path('.')",
          "Path('./Output/business_deposits_tin_raw_data.xlsx')",
          "BASE_PATH =",
          "BASE_PATH =",
          "production_flag",
          "production_flag",
          "production_flag"
        ],
        "version": ")\n    else:\n        BASE_PATH = Path(",
        "functions": [
          "main"
        ],
        "schedule_hints": [],
        "data_sources": [],
        "file_operations": []
      },
      "fetch_data": {}
    }
  },
  {
    "report_id": "Retail/New_Consumer_Checking",
    "name": "New_Consumer_Checking",
    "business_line": "Retail",
    "purpose": "New Business Checking\nDeveloped by CD\n[v1.0.5-prod] ",
    "frequency": "manual",
    "has_email": false,
    "data_sources": [],
    "version": ")\n    else:\n        BASE_PATH = Path(",
    "functions": [
      "main"
    ],
    "needs_config": true,
    "analysis": {
      "main": {
        "docstring": "New Business Checking\nDeveloped by CD\n[v1.0.5-prod] ",
        "imports": [
          "from pathlib",
          "import os",
          "import pandas",
          "import src.cdutils.database",
          "from src._version"
        ],
        "database_queries": [],
        "output_patterns": [
          ".to_excel(FILE_PATH, engine='openpyxl', index=False)"
        ],
        "email_patterns": [],
        "path_patterns": [
          "r'\\\\00-DA1\\Home\\Share\\Line of Business_Shared Services\\Retail Banking\\New Consumer Checking\\Production'",
          "Path(r'\\\\00-DA1\\Home\\Share\\Line of Business_Shared Services\\Retail Banking\\New Consumer Checking\\Production')",
          "Path('.')",
          "Path('./output')",
          "BASE_PATH =",
          "BASE_PATH =",
          "production_flag",
          "production_flag",
          "production_flag"
        ],
        "version": ")\n    else:\n        BASE_PATH = Path(",
        "functions": [
          "main"
        ],
        "schedule_hints": [],
        "data_sources": [],
        "file_operations": []
      },
      "fetch_data": {}
    }
  },
  {
    "report_id": "Retail/Prime_Time_Travel_customers",
    "name": "Prime_Time_Travel_customers",
    "business_line": "Retail",
    "purpose": "Unknown",
    "frequency": "manual",
    "has_email": false,
    "data_sources": [
      "OSIBANK",
      "sqlalchemy",
      "WH_",
      "OSIEXTN"
    ],
    "version": null,
    "functions": [
      "main"
    ],
    "needs_config": true,
    "analysis": {
      "main": {
        "docstring": null,
        "imports": [
          "import src.getAllData",
          "import src.pkey",
          "import src.format_excel_file",
          "from src._version",
          "import pandas",
          "from datetime",
          "from pathlib"
        ],
        "database_queries": [],
        "output_patterns": [
          ".to_excel(output_file_path, index=False)",
          "output_file_path = Path(r\"\\\\00-da1\\Home\\Share\\Line of Business_Shared Services\\Retail Banking\\Prime_Time_Travel_customers\\Production\\output\") / Path",
          "output_file_path = Path(r\"\\\\00-da1\\Home\\Share\\Data & Analytics Initiatives\\Project Management\\Retail\\Prime_Time_Travel_customers\\Production\\output\") / Path"
        ],
        "email_patterns": [],
        "path_patterns": [
          "r\"\\\\00-da1\\Home\\Share\\Line of Business_Shared Services\\Retail Banking\\Prime_Time_Travel_customers\\Production\\output\"",
          "r\"\\\\00-da1\\Home\\Share\\Data & Analytics Initiatives\\Project Management\\Retail\\Prime_Time_Travel_customers\\Production\\output\"",
          "Path(r\"\\\\00-da1\\Home\\Share\\Line of Business_Shared Services\\Retail Banking\\Prime_Time_Travel_customers\\Production\\output\")",
          "Path(\"Prime Time Travel Customers \" + date + \".xlsx\")",
          "Path(r\"\\\\00-da1\\Home\\Share\\Data & Analytics Initiatives\\Project Management\\Retail\\Prime_Time_Travel_customers\\Production\\output\")",
          "Path(\"Prime Time Travel Customers \" + date + \".xlsx\")",
          "production_flag",
          "production_flag",
          "production_flag"
        ],
        "version": null,
        "functions": [
          "main"
        ],
        "schedule_hints": [],
        "data_sources": [
          "WH_"
        ],
        "file_operations": []
      },
      "fetch_data": {
        "queries": [
          "text(f\"\"\"\n    SELECT\n        a.EFFDATE,\n        a.ACCTNBR,\n        a.OWNERSORTNAME,\n        a.PRODUCT,\n        a.NOTEOPENAMT,\n        a.RATETYPCD,\n        a.MJACCTTYPCD,\n        a.CURRMIACCTTYPCD,\n        a.CURRACCTSTATCD,\n        a.NOTEINTRATE,\n        a.BOOKBALANCE,\n        a.NOTEBAL,\n        a.CONTRACTDATE,\n        a.DATEMAT,\n        a.TAXRPTFORORGNBR,\n        a.TAXRPTFORPERSNBR,\n        a.LOANOFFICER,\n        a.ACCTOFFICER\n    FROM\n        OSIBANK.WH_ACCTCOMMON a\n    WHERE\n        (a.CURRACCTSTATCD IN ('ACT','NPFM','DORM','CO')",
          "text(f\"\"\"\n    SELECT\n        a.ACCTNBR,\n        a.ORIGDATE,\n        a.CURRTERM,\n        a.LOANIDX,\n        a.RCF,\n        a.AVAILBALAMT,\n        a.FDICCATDESC,\n        a.ORIGBAL,\n        a.LOANLIMITYN\n    FROM\n        OSIBANK.WH_LOANS a\n    \"\"\")",
          "text(f\"\"\"\n    SELECT\n        a.ACCTNBR,\n        a.CREDITLIMITAMT,\n        a.ORIGINTRATE,\n        a.MARGINFIXED,\n        a.FDICCATCD,\n        a.AMORTTERM,\n        a.TOTALPCTSOLD,\n        a.COBAL,\n        a.CREDLIMITCLATRESAMT,\n        a.RISKRATINGCD\n    FROM\n        OSIBANK.WH_ACCTLOAN a\n    \"\"\")",
          "text(\"\"\"\n    SELECT\n        a.ACCTNBR,\n        a.HOUSEHOLDNBR,\n        a.DATELASTMAINT\n    FROM\n        OSIEXTN.HOUSEHLDACCT a\n    \"\"\")",
          "text(\"\"\"\n    SELECT\n        *\n    FROM\n        OSIBANK.WH_PERS a\n    \"\"\")"
        ],
        "tables": [
          "OSIBANK",
          "sqlalchemy",
          "OSIEXTN"
        ],
        "databases": []
      }
    }
  },
  {
    "report_id": "Operations/Rate Scraping",
    "name": "Rate Scraping",
    "business_line": "Operations",
    "purpose": "Unknown",
    "frequency": "daily",
    "has_email": true,
    "data_sources": [
      "COCC"
    ],
    "version": null,
    "functions": [
      "fetch_full_fred_data",
      "get_cme_term_sofr_data",
      "fetch_fhlbb_rates",
      "export_rate_table_to_excel"
    ],
    "needs_config": true,
    "analysis": {
      "main": {
        "docstring": null,
        "imports": [
          "import requests",
          "import pandas",
          "import json",
          "import os",
          "from pathlib",
          "from playwright.sync_api",
          "from openpyxl",
          "from openpyxl.styles",
          "from openpyxl.utils.dataframe",
          "import cdutils.distribution",
          "import shutil",
          "import win32com.client",
          "import warnings"
        ],
        "database_queries": [
          "Finished Rate Scraper",
          "Selector('body').innerText\")\n        data = json.loads(body_text)\n\n        latest = data[\"resultsStrip\"][0]\n        return {\n            \"1M\": float(next(r[\"price\"] for r in latest[\"rates\"][\"sofrRatesFixing\"] if r[\"term\"] == \"1M\")),\n            \"30D\": float(latest[\"average30day\"]),\n            \"date\": latest[\"date\"]\n        }\n\n\ndef fetch_fhlbb_rates():\n    with sync_playwright() as p:\n        browser = p.chromium.launch(headless=False)\n        context = browser.new_context(accept_downloads=True)\n        page = context.new_page()\n\n        page.goto(\"https://www.fhlbboston.com/fhlbank-boston/rates#/long-term\", timeout=20000)\n        with page.expect_download() as download_info:\n            page.click(\"text=Download Today's Rates \u2013 Excel\")\n        download = download_info.value\n\n        file_path = Path(download.suggested_filename)\n        download.save_as(str(file_path))\n\n        df = pd.read_excel(file_path, header=None)\n        file_path.unlink()\n        assert(df.at[42, 1] == \"1 YEAR\")\n        assert(df.at[31, 3] == \"CDA\")\n        assert(df.at[71, 3] == \"CDA\")\n        return {\n            \"Effective Date (Classics)\": df.at[29, 1],\n            \"1Y Classic\": df.at[42, 2],\n            \"2Y Classic\": df.at[46, 2],\n            \"3Y Classic\": df.at[50, 2],\n            \"3Y CDA\": df.at[50, 3],\n            \"4Y Classic\": df.at[52, 2],\n            \"5Y Classic\": df.at[54, 2],\n            \"5Y CDA\": df.at[54, 3],\n            \"6Y Classic\": df.at[56, 2],\n            \"7Y Classic\": df.at[58, 2],\n            \"7Y CDA\": df.at[58, 3],\n            \"10Y Classic\": df.at[64, 2],\n            \"Effective Date (Amortizing)\": df.at[69, 1],\n            \"5/5 Amortizing\": df.at[100, 2],\n            \"5/20 Amortizing\": df.at[106, 2],\n            \"10/10 Amortizing\": df.at[124, 2],\n        }\n\n\ndef export_rate_table_to_excel(fred_data, cme_data, fhlb_data):\n    from openpyxl import Workbook\n    from openpyxl.styles import Font, Alignment, PatternFill, Border, Side\n    from openpyxl.utils.dataframe import dataframe_to_rows\n    from datetime import datetime\n\n    warnings.filterwarnings(\"ignore\", category=UserWarning, module=\"openpyxl.styles.stylesheet\")\n    # Timestamp\n    now = datetime.now()\n    timestamp_str = now.strftime(\"%B %d, %Y at %I:%M %p EST\")\n    filename_str = now.strftime(\"Rate_Report_%b_%d_%y_%H%M.xlsx\")\n\n    # Prepare rows\n    rows = []\n    for row in RATE_TABLE_TEMPLATE:\n        source = row[\"source\"]\n        key = row[\"key\"]\n        rate, date = \"\", \"\"\n\n        if source == \"FRED\":\n            data = fred_data.get(key, {})\n            rate = data.get(\"value\")\n            date = data.get(\"date\")\n        elif source == \"CME\":\n            rate = cme_data.get(key)\n            date = cme_data.get(\"date\")\n        elif source == \"FHLB\":\n            rate = fhlb_data.get(key)\n            date = fhlb_data.get(\"Effective Date (Classics)\") or fhlb_data.get(\"Effective Date (Amortizing)\")\n\n        # Convert to float\n        if isinstance(rate, str):\n            try:\n                rate = float(rate.replace(\",\", \"\"))\n            except:\n                pass\n\n        rows.append({\n            \"Index Description / Laser Pro Description\": row[\"desc\"],\n            \"Schedule\\nNumber\": row[\"sched\"],\n            \"New Rate\": rate,\n            \"Observation Date\": date,\n            \"Field Name\": row[\"field\"]\n        })\n\n    df = pd.DataFrame(rows)\n\n    # Create workbook\n    wb = Workbook()\n    ws = wb.active\n    ws.title = \"Rate Table\"\n\n    # Styles\n    header_font = Font(bold=True, size=13)\n    body_font = Font(size=12)\n    rate_font = Font(size=15, bold=True)\n    center_align = Alignment(horizontal=\"center\", vertical=\"center\", wrap_text=True)\n    wrap_align = Alignment(wrap_text=True, vertical=\"top\")\n    zebra_fill = PatternFill(start_color=\"F2F2F2\", end_color=\"F2F2F2\", fill_type=\"solid\")\n    border = Border(\n        left=Side(style='thin'),\n        right=Side(style='thin'),\n        top=Side(style='thin'),\n        bottom=Side(style='thin')\n    )\n\n    # Freeze header row (row 2)\n    ws.freeze_panes = \"A3\"\n\n    # Write report info merged across row 1\n    info_text = \"Reviewed By:__________________________________________\"\n    ws.merge_cells(\"A1:E1\")\n    info_cell = ws[\"A1\"]\n    info_cell.value = info_text\n    info_cell.font = Font(size=18)\n    info_cell.alignment = Alignment(wrap_text=False, vertical=\"top\")\n    \n    info_text = f\"Generated on {timestamp_str} by BCSB Data and Analytics\\nBusinessintelligence@bcsbmail.com\"\n    ws.merge_cells(\"A2:E2\")\n    info_cell = ws[\"A2\"]\n    info_cell.value = info_text\n    info_cell.font = Font(italic=True, size=11)\n    info_cell.alignment = Alignment(wrap_text=True, vertical=\"top\")\n\n    # Write data\n    for r_idx, row in enumerate(dataframe_to_rows(df, index=False, header=True), start=3):\n        ws.append(row)\n\n        if r_idx == 3:\n            for cell in ws[r_idx]:\n                cell.font = header_font\n                cell.alignment = center_align\n                cell.border = border\n        else:\n            ws.row_dimensions[r_idx].height = 45\n            if r_idx % 2 == 0:\n                for cell in ws[r_idx]:\n                    cell.fill = zebra_fill\n            for c_idx, cell in enumerate(ws[r_idx], start=1):\n                cell.font = body_font\n                cell.border = border\n                if c_idx == 1:\n                    cell.alignment = wrap_align\n                elif c_idx == 3 and isinstance(cell.value, (int, float)):\n                    cell.number_format = '#0.00#############'\n\n                    cell.font = rate_font\n                    cell.alignment = center_align\n                else:\n                    cell.alignment = center_align\n\n    # Adjust column widths\n    column_widths = {\n        1: 42,\n        2: 12,\n        3: 18,\n        4: 20,\n        5: 25\n    }\n    for col_idx, width in column_widths.items():\n        ws.column_dimensions[chr(64 + col_idx)].width = width\n    \n\n\n    output_path = OUTPUT_DIR / filename_str\n    pdf_path = OUTPUT_DIR  / filename_str\n    pdf_path = str(pdf_path).replace(\".xlsxpdf\",\"\")\n    pdf_path = pdf_path.replace(\".xlsx\",\"\")\n\n    # Save\n    wb.save(output_path)\n    print(f\"Excel table written to {output_path}\")\n    \n    win32.gencache.is_readonly = False\n    win32.gencache.Rebuild()\n    excel = win32.gencache.EnsureDispatch('Excel.Application')\n    wb = excel.Workbooks.Open(output_path)\n    ws = wb.Worksheets(1)\n    ws.PageSetup.Orientation = 1\n    ws.PageSetup.Zoom = False\n    ws.PageSetup.FitToPagesWide = 1\n    ws.PageSetup.FitToPagesTall = 1\n    ws.PageSetup.TopMargin = 0.5\n    ws.PageSetup.BottomMargin = 0.2\n    wb.ExportAsFixedFormat(0, str(pdf_path))\n    wb.Close(False)\n    excel.Quit()\n    print(f\"Excel table written to PDF {pdf_path}\")\n\n    # Distribution\n    recipients = [\n        \"Kelly.Abernathy@bcsbmail.com\",\n        \"Taylor.Willbanks@bcsbmail.com\",\n        \"Josephine.Willard@bcsbmail.com\",\n        \"Patty.DeSimone@bcsbmail.com\",\n        \"Zachary.Cabral@bcsbmail.com\",\n        \"Tanner.Vickery@bcsbmail.com\"\n    ]\n    bcc_recipients = [\n        \"chad.doorley@bcsbmail.com\",\n        \"businessintelligence@bcsbmail.com\",\n    ]\n\n    time_subjectline = now.strftime(\"%B %d, %Y\")\n\n    subject = f\"Daily Rate Scrape - {time_subjectline}\" \n    body = \"Hi, \\n\\nAttached is the Daily Rate Scrape Report. If you have any questions, please reach out to BusinessIntelligence@bcsbmail.com \\n\\nThanks!\"\n    PDF_ATTACHMENT = Path(pdf_path + '.pdf')  \n    # print(PDF_ATTACHMENT)\n    attachment_paths = [PDF_ATTACHMENT]\n    cdutils.distribution.email_out(recipients, bcc_recipients, subject, body, attachment_paths)\n\n    # Drop in Ops folder\n    OPS_OUTPUT_PATH = Path(r\"\\\\00-berlin\\Operations\\Loan Servicing\\Daily Rate Updates\\Output\")\n    OPS_OUTPUT_PATH.parent.mkdir(parents=True, exist_ok=True)\n    shutil.copy2(PDF_ATTACHMENT, OPS_OUTPUT_PATH)\n\n\n\n\nif __name__ == '__main__':\n    \n    print(\"Running Rate Scraper\")\n    fred_series_ids = [\"WGS1YR\", \"GS1\", \"WGS3YR\", \"WGS5YR\"]\n    fred_data = fetch_full_fred_data(fred_series_ids)\n    cme_data = get_cme_term_sofr_data()\n    fhlb_data = fetch_fhlbb_rates()\n    export_rate_table_to_excel(fred_data, cme_data, fhlb_data)\n    print(\"Finished Rate Scraper\")",
          "text("
        ],
        "output_patterns": [
          "output_path = OUTPUT_DIR / filename_str",
          "OUTPUT_PATH = Path(r\"\\\\00-berlin\\Operations\\Loan Servicing\\Daily Rate Updates\\Output\")",
          "OUTPUT_PATH.parent.mkdir(parents=True, exist_ok=True)",
          "OUTPUT_PATH = Path",
          ".save("
        ],
        "email_patterns": [
          "email_out(",
          "distribution.",
          "@bcsbmail.com",
          "@bcsbmail.com",
          "@bcsbmail.com",
          "@bcsbmail.com",
          "@bcsbmail.com",
          "@bcsbmail.com",
          "@bcsbmail.com",
          "@bcsbmail.com",
          "@bcsbmail.com",
          "@bcsbmail.com",
          "recipients =",
          "recipients ="
        ],
        "path_patterns": [
          "r\"\\\\00-berlin\\Operations\\Loan Servicing\\Daily Rate Updates\\Output\"",
          "Path(__file__)",
          "Path(download.suggested_filename)",
          "Path(pdf_path + '.pdf')",
          "Path(r\"\\\\00-berlin\\Operations\\Loan Servicing\\Daily Rate Updates\\Output\")"
        ],
        "version": null,
        "functions": [
          "fetch_full_fred_data",
          "get_cme_term_sofr_data",
          "fetch_fhlbb_rates",
          "export_rate_table_to_excel"
        ],
        "schedule_hints": [
          "daily",
          "weekly",
          "monthly"
        ],
        "data_sources": [
          "COCC"
        ],
        "file_operations": [
          "read_excel"
        ]
      },
      "fetch_data": {}
    }
  },
  {
    "report_id": "Operations/Trial Balance Ops",
    "name": "Trial Balance Ops",
    "business_line": "Operations",
    "purpose": "Main Entry Point",
    "frequency": "manual",
    "has_email": true,
    "data_sources": [
      "OSIBANK",
      "sqlalchemy",
      "COCCDM"
    ],
    "version": ")\n    else:\n        BASE_PATH = Path(",
    "functions": [
      "main"
    ],
    "needs_config": true,
    "analysis": {
      "main": {
        "docstring": "Main Entry Point",
        "imports": [
          "from datetime",
          "from dateutil.relativedelta",
          "from pathlib",
          "import pandas",
          "import src.fetch_data",
          "import src.core_transform",
          "import cdutils.distribution",
          "import src.output_to_excel",
          "from src._version"
        ],
        "database_queries": [],
        "output_patterns": [
          ".to_excel(OUTPUT_PATH_SINGLE, sheet_name='Sheet1', index=False)",
          ".to_excel(OUTPUT_PATH_MULTIPLE, sheet_name='Sheet1', index=False)",
          "OUTPUT_PATH_SINGLE = BASE_PATH / Path(f'./output/CML_Trial_Balance_Ops_{current_date}.xlsx')",
          "OUTPUT_PATH_SINGLE, sheet_name='Sheet1', index=False)",
          "OUTPUT_PATH_MULTIPLE = BASE_PATH / Path(f'./output/CML_Trial_Balance_Ops_MultipleProperties{current_date}.xlsx')",
          "OUTPUT_PATH_MULTIPLE, sheet_name='Sheet1', index=False)",
          "OUTPUT_PATH_SINGLE = BASE_PATH / Path",
          "OUTPUT_PATH_MULTIPLE = BASE_PATH / Path"
        ],
        "email_patterns": [
          "email_out(",
          "distribution.",
          "@bcsbmail.com",
          "@bcsbmail.com",
          "@bcsbmail.com",
          "@bcsbmail.com",
          "@bcsbmail.com",
          "@bcsbmail.com",
          "recipients =",
          "recipients =",
          "recipients =",
          "recipients ="
        ],
        "path_patterns": [
          "r'\\\\00-DA1\\Home\\Share\\Line of Business_Shared Services\\Operations\\Trial Balance Ops'",
          "Path(r'\\\\00-DA1\\Home\\Share\\Line of Business_Shared Services\\Operations\\Trial Balance Ops')",
          "Path('.')",
          "Path(f'./output/CML_Trial_Balance_Ops_{current_date}.xlsx')",
          "Path(f'./output/CML_Trial_Balance_Ops_MultipleProperties{current_date}.xlsx')",
          "BASE_PATH =",
          "BASE_PATH =",
          "production_flag",
          "production_flag",
          "production_flag"
        ],
        "version": ")\n    else:\n        BASE_PATH = Path(",
        "functions": [
          "main"
        ],
        "schedule_hints": [],
        "data_sources": [],
        "file_operations": []
      },
      "fetch_data": {
        "queries": [
          "text(\"\"\"\n    SELECT \n        a.ACCTNBR,\n        a.MJACCTTYPCD,\n        a.CURRMIACCTTYPCD,\n        a.PRODUCT,\n        a.CURRACCTSTATCD,\n        a.NOTEINTRATE,\n        a.NOTENEXTRATECHANGEDATE,\n        a.NOTERATECHANGECALPERCD,\n        a.NOTEOPENAMT,\n        a.NOTEBAL,\n        a.BOOKBALANCE,\n        a.NOTEINTCALCSCHEDNBR,\n        a.CALCBALTYPCD,\n        a.INTMETHCD,\n        a.RATETYPCD,\n        a.INTBASE,\n        a.DATEMAT,\n        a.CONTRACTDATE,\n        a.OWNERNAME\n    FROM \n        COCCDM.WH_ACCTCOMMON_ME a\n    \"\"\")",
          "text(\"\"\"\n    SELECT \n        a.ACCTNBR, \n        a.COBAL,\n        a.ESCBAL, \n        a.PURPCD,\n        a.FDICCATCD,\n        a.DATE1STPMTDUE,\n        a.MINRATECHANGEDOWN, \n        a.MAXRATECHANGEDOWN, \n        a.PREPAYCHARGE,\n        a.LASTPAYMENTDATE,\n        a.NOTEACCRUEDINT\n    FROM \n        COCCDM.WH_ACCTLOAN_ME a\n    \"\"\")",
          "text(\"\"\"\n    SELECT \n        a.ACCTNBR, \n        a.AVAILBALAMT,\n        a.INTPAIDTODATE,\n        a.FDICCATDESC,\n        a.LOANIDX\n    FROM \n        COCCDM.WH_LOANS_ME a\n    \"\"\")",
          "text(\"\"\"\n    SELECT\n        a.ACCTNBR,\n        a.PROPNBR,\n        a.APRSVALUEAMT,\n        a.APRSDATE,\n        a.PROPADDR1,\n        a.PROPADDR2,\n        a.PROPADDR3,\n        a.PROPCITY,\n        a.PROPSTATE,\n        a.PROPZIP\n    FROM\n        OSIBANK.WH_PROP a\n    \"\"\")",
          "text(\"\"\"\n    SELECT\n        a.ACCTNBR,\n        a.PROPTYPDESC,\n        a.PROPNBR,\n        a.PROPVALUE,\n        a.PROPTYPCD,\n        a.PROPDESC\n    FROM\n        OSIBANK.WH_PROP2 a\n    \"\"\")"
        ],
        "tables": [
          "OSIBANK",
          "sqlalchemy",
          "COCCDM"
        ],
        "databases": []
      }
    }
  },
  {
    "report_id": "Government Banking/Payroll_and_Vendor",
    "name": "Payroll_and_Vendor",
    "business_line": "Government Banking",
    "purpose": "Unknown",
    "frequency": "manual",
    "has_email": false,
    "data_sources": [
      "ACCT",
      "COCC",
      "WH_"
    ],
    "version": ")\n    else:\n        BASE_PATH = Path(",
    "functions": [
      "main"
    ],
    "needs_config": true,
    "analysis": {
      "main": {
        "docstring": null,
        "imports": [
          "import cdutils.database.connect",
          "from sqlalchemy",
          "from datetime",
          "from src._version",
          "from pathlib"
        ],
        "database_queries": [
          "Complete!",
          "Complete!",
          "select COCCDM.WH_RTXN.ACCTNBR,\n                COCCDM.WH_RTXN.POSTDATE,\n                COCCDM.WH_RTXN.CHECKNBR,\n                COCCDM.WH_RTXN.TRANAMT \n            from COCCDM.WH_RTXN \n            where COCCDM.WH_RTXN.ACCTNBR = 150523994.00 \n                and COCCDM.WH_RTXN.POSTDATE >= TO_DATE('{start_date}', 'yyyy-mm-dd hh24:mi:ss') \n                and COCCDM.WH_RTXN.POSTDATE <= TO_DATE('{end_date}', 'yyyy-mm-dd hh24:mi:ss')\n            and COCCDM.WH_RTXN.CHECKNBR is not NULL\n        \"\"\")\n        \n        payroll_query = text(f\"\"\"\n            select COCCDM.WH_RTXN.ACCTNBR,\n                COCCDM.WH_RTXN.POSTDATE,\n                COCCDM.WH_RTXN.CHECKNBR,\n                COCCDM.WH_RTXN.TRANAMT \n            from COCCDM.WH_RTXN \n            where COCCDM.WH_RTXN.ACCTNBR = 150524009.00 \n                and COCCDM.WH_RTXN.POSTDATE >= TO_DATE('{start_date}', 'yyyy-mm-dd hh24:mi:ss') \n                and COCCDM.WH_RTXN.POSTDATE <= TO_DATE('{end_date}', 'yyyy-mm-dd hh24:mi:ss')\n            and COCCDM.WH_RTXN.CHECKNBR is not NULL    \n            \"\"\")\n\n        queries = [\n            {'key':'vendor_query', 'sql':vendor_query, 'engine':2},\n            {'key':'payroll_query', 'sql':payroll_query, 'engine':2}\n        ]\n\n\n        data = cdutils.database.connect.retrieve_data(queries)\n        return data\n\n    data = fetch_data()\n\n    vendor_query = data['vendor_query'].copy()\n    payroll_query = data['payroll_query'].copy()\n\n\n    def format_payroll_row(row):\n        acct_prefix = \"  R150524009 \"\n        checknbr = str(row['checknbr']).zfill(10)\n        postdate = row['postdate'].strftime('%m%d%y')\n        tranamt_abs = abs(float(row['tranamt']))  # Ensure it's positive\n        tranamt_str = f\"{tranamt_abs:.2f}\".replace('.', '')  # Remove decimal point\n        tranamt_padded = tranamt_str.zfill(10)\n        return f\"{acct_prefix}{checknbr}{postdate}{tranamt_padded}\"\n\n    # Format each row\n    formatted_lines = payroll_query.apply(format_payroll_row, axis=1).tolist()\n\n    # Payroll output path\n    PAYROLL_OUTPUT_PATH = Path('./output/payroll_report.txt') \n\n    # Write to a .txt file\n    with open(PAYROLL_OUTPUT_PATH, \"w\") as f:\n        for line in formatted_lines:\n            f.write(line + \"\\n\")\n            \n    import pandas as pd\n\n    # Format vendor data to match the required output\n    vendor_formatted = vendor_query.copy()\n\n    # Make transaction amount positive\n    vendor_formatted['tranamt'] = vendor_formatted['tranamt'].abs()\n\n    # Format postdate to MM/DD/YYYY\n    vendor_formatted['postdate'] = vendor_formatted['postdate'].dt.strftime('%m/%d/%Y')\n\n    # Create output DataFrame with 6 columns\n    vendor_output = vendor_formatted[['acctnbr', 'checknbr', 'tranamt', 'postdate']].copy()\n\n    # Insert empty columns in the correct positions\n    vendor_output.insert(3, '', '')  # Blank column after tranamt\n\n    vendor_output = vendor_output[['acctnbr', 'checknbr', 'tranamt', '', '', 'postdate']]\n\n    # Write to CSV without header and index\n    VENDOR_OUTPUT_PATH = Path('./output/vendor_report.csv') \n\n    vendor_output.to_csv(VENDOR_OUTPUT_PATH, index=False, header=False)\n\n\nif __name__ == \"__main__\":\n    print(f\"Starting [{__version__}]\")\n    # main(production_flag=True)\n    main()\n    print(\"Complete!\")\n        \n    ",
          "text(",
          "text("
        ],
        "output_patterns": [
          ".to_csv(VENDOR_OUTPUT_PATH, index=False, header=False)",
          "OUTPUT_PATH = Path('./output/payroll_report.txt') ",
          "OUTPUT_PATH = Path('./output/vendor_report.csv') ",
          "OUTPUT_PATH, index=False, header=False)",
          "OUTPUT_PATH = Path",
          "OUTPUT_PATH = Path"
        ],
        "email_patterns": [],
        "path_patterns": [
          "r'\\\\00-DA1\\Home\\Share\\Data & Analytics Initiatives\\Project Management\\Government Banking\\Payroll_and_Vendor'",
          "Path(r'\\\\00-DA1\\Home\\Share\\Data & Analytics Initiatives\\Project Management\\Government Banking\\Payroll_and_Vendor')",
          "Path('.')",
          "Path('./output/payroll_report.txt')",
          "Path('./output/vendor_report.csv')",
          "BASE_PATH =",
          "BASE_PATH =",
          "BASE_PATH =",
          "PRODUCTION_FLAG",
          "production_flag",
          "production_flag",
          "production_flag"
        ],
        "version": ")\n    else:\n        BASE_PATH = Path(",
        "functions": [
          "main"
        ],
        "schedule_hints": [],
        "data_sources": [
          "COCC",
          "WH_",
          "ACCT"
        ],
        "file_operations": [
          "open("
        ]
      },
      "fetch_data": {}
    }
  },
  {
    "report_id": "Resolution Committee Automation/Financial Difficulty Modifications",
    "name": "Financial Difficulty Modifications",
    "business_line": "Resolution Committee Automation",
    "purpose": "Unknown",
    "frequency": "manual",
    "has_email": false,
    "data_sources": [],
    "version": ")\n    else:\n        BASE_PATH = Path(",
    "functions": [
      "main"
    ],
    "needs_config": true,
    "analysis": {
      "main": {
        "docstring": null,
        "imports": [
          "from sqlalchemy",
          "import sys",
          "import os",
          "import cdutils.database.connect",
          "import pandas",
          "from datetime",
          "from openpyxl",
          "from openpyxl.utils",
          "from openpyxl.styles",
          "import numpy",
          "from pathlib",
          "import pandas",
          "from datetime",
          "from src._version"
        ],
        "database_queries": [
          "Complete!"
        ],
        "output_patterns": [
          "OUTPUT_PATH: Path = BASE_PATH / Path('./Output')",
          "output_path = OUTPUT_PATH / f\"{curr_end_xlsx}\"",
          "OUTPUT_PATH: Path = BASE_PATH / Path",
          "output_path = OUTPUT_PATH",
          ".save("
        ],
        "email_patterns": [],
        "path_patterns": [
          "r'\\\\00-DA1\\Home\\Share\\Data & Analytics Initiatives\\Project Management\\Credit_Loan_Review\\Resolution Committee Automation\\Financial Difficulty Modifications\\Production'",
          "Path(r'\\\\00-DA1\\Home\\Share\\Data & Analytics Initiatives\\Project Management\\Credit_Loan_Review\\Resolution Committee Automation\\Financial Difficulty Modifications\\Production')",
          "Path('.')",
          "Path('./Output')",
          "BASE_PATH =",
          "BASE_PATH =",
          "PRODUCTION_FLAG",
          "production_flag",
          "production_flag"
        ],
        "version": ")\n    else:\n        BASE_PATH = Path(",
        "functions": [
          "main"
        ],
        "schedule_hints": [],
        "data_sources": [],
        "file_operations": [
          "load_workbook"
        ]
      },
      "fetch_data": {}
    }
  },
  {
    "report_id": "Resolution Committee Automation/Delinquency",
    "name": "Delinquency",
    "business_line": "Resolution Committee Automation",
    "purpose": "Delinquency Report main entry point\n- Developed by CD\n- v2.0.0-prod\n\nUsage:\n```\npython -m src.main\n```",
    "frequency": "monthly",
    "has_email": true,
    "data_sources": [
      "sqlalchemy",
      "COCC",
      "ACCT",
      "WH_",
      "COCCDM",
      "LOAN",
      "OSIBANK"
    ],
    "version": ")\n    # main(production_flag=True)\n    main()\n    print(",
    "functions": [
      "acctstatistichist_cleaning",
      "count_pd",
      "isolate_total_past_due",
      "merging_tables",
      "append_pd_stats",
      "create_validation_model",
      "unpack_validation_model",
      "section_creation",
      "main"
    ],
    "needs_config": false,
    "analysis": {
      "main": {
        "docstring": "Delinquency Report main entry point\n- Developed by CD\n- v2.0.0-prod\n\nUsage:\n```\npython -m src.main\n```",
        "imports": [
          "import os",
          "from datetime",
          "from typing",
          "import numpy",
          "from openpyxl",
          "from openpyxl.styles",
          "from sqlalchemy",
          "from pydantic",
          "from win32com.client",
          "import pandas",
          "import src.fetch_data",
          "import cdutils.distribution",
          "from src._version"
        ],
        "database_queries": [
          "Complete!"
        ],
        "output_patterns": [
          ".to_excel(writer, index=False, sheet_name='Sheet1', startrow=4)",
          "output_file = os.path",
          ".save(",
          "ExcelWriter"
        ],
        "email_patterns": [
          "email_out(",
          "distribution.",
          "@bcsbmail.com",
          "@bcsbmail.com",
          "@bcsbmail.com",
          "@bcsbmail.com",
          "@bcsbmail.com",
          "@bcsbmail.com",
          "recipients =",
          "recipients =",
          "recipients=",
          "recipients="
        ],
        "path_patterns": [
          "r\"\\\\00-da1\\Home\\Share\\Data & Analytics Initiatives\\Project Management\\Credit_Loan_Review\\Resolution Committee Automation\\Delinquency\\Production\\Output\"",
          "production_flag"
        ],
        "version": ")\n    # main(production_flag=True)\n    main()\n    print(",
        "functions": [
          "acctstatistichist_cleaning",
          "count_pd",
          "isolate_total_past_due",
          "merging_tables",
          "append_pd_stats",
          "create_validation_model",
          "unpack_validation_model",
          "section_creation",
          "main"
        ],
        "schedule_hints": [
          "monthly"
        ],
        "data_sources": [
          "COCC",
          "WH_",
          "ACCT",
          "LOAN"
        ],
        "file_operations": [
          "load_workbook"
        ]
      },
      "fetch_data": {
        "queries": [
          "text(\"\"\"\n    SELECT\n        a.ACCTNBR,\n        a.PRODUCT,\n        a.OWNERSORTNAME,\n        a.LOANOFFICER,\n        a.NOTEBAL,\n        a.BOOKBALANCE,\n        a.CURRACCTSTATCD,\n        a.MJACCTTYPCD,\n        a.EFFDATE\n    FROM \n        COCCDM.WH_ACCTCOMMON_ME a\n    WHERE\n        CURRACCTSTATCD IN ('ACT','NPFM')",
          "text(\"\"\"\n    SELECT\n        a.ACCTNBR,\n        a.CURRDUEDATE,\n        a.COBAL,\n        a.TOTALPAYMENTSDUE,\n        a.TOTALPIDUE,\n        a.TOTALPCTSOLD,\n        a.RISKRATINGCD\n    FROM \n        COCCDM.WH_ACCTLOAN_ME a\n    \"\"\")",
          "text(\"\"\"\n    SELECT\n        *\n    FROM \n        COCCDM.WH_TOTALPAYMENTSDUE a\n    \"\"\")",
          "text(\"\"\"\n    SELECT \n        *\n    FROM \n        OSIBANK.ACCTSTATISTICHIST\n    \"\"\")"
        ],
        "tables": [
          "OSIBANK",
          "sqlalchemy",
          "COCCDM"
        ],
        "databases": []
      }
    }
  },
  {
    "report_id": "Resolution Committee Automation/Classifieds",
    "name": "Classifieds",
    "business_line": "Resolution Committee Automation",
    "purpose": "Unknown",
    "frequency": "monthly",
    "has_email": false,
    "data_sources": [
      "COCC",
      "ACCT",
      "WH_",
      "LOAN",
      "Oracle"
    ],
    "version": ")\n    else:\n        BASE_PATH = Path(",
    "functions": [
      "main"
    ],
    "needs_config": true,
    "analysis": {
      "main": {
        "docstring": null,
        "imports": [
          "from sqlalchemy",
          "import sys",
          "import os",
          "import cdutils.database.connect",
          "import pandas",
          "from datetime",
          "from openpyxl",
          "from openpyxl.utils",
          "from openpyxl.styles",
          "import numpy",
          "from pathlib",
          "import pandas",
          "from datetime",
          "from src._version"
        ],
        "database_queries": [
          "Complete!",
          "SELECT\n                a.EFFDATE,\n                a.ACCTNBR,\n                a.OWNERSORTNAME,\n                a.PRODUCT,\n                a.NOTEOPENAMT,\n                a.RATETYPCD,\n                a.MJACCTTYPCD,\n                a.CURRMIACCTTYPCD,\n                a.CURRACCTSTATCD,\n                a.NOTEINTRATE,\n                a.BOOKBALANCE,\n                a.NOTEBAL,\n                a.LOANOFFICER,\n                a.ACCTOFFICER,\n                a.TAXRPTFORORGNBR,\n                a.TAXRPTFORPERSNBR\n            FROM COCCDM.WH_ACCTCOMMON a\n            WHERE a.CURRACCTSTATCD IN ('ACT','NPFM')\n            AND a.EFFDATE = {effdate_sql}\n        \"\"\")\n\n        wh_loans = text(f\"\"\"\n            SELECT\n                a.ACCTNBR,\n                a.ORIGDATE,\n                a.CURRTERM,\n                a.LOANIDX,\n                a.RCF,\n                a.AVAILBALAMT,\n                a.FDICCATDESC,\n                a.ORIGBAL\n            FROM COCCDM.WH_LOANS a\n            WHERE a.RUNDATE = {effdate_sql}\n        \"\"\")\n\n        wh_acctloan = text(f\"\"\"\n            SELECT\n                a.ACCTNBR,\n                a.CREDITLIMITAMT,\n                a.ORIGINTRATE,\n                a.MARGINFIXED,\n                a.FDICCATCD,\n                a.AMORTTERM,\n                a.TOTALPCTSOLD,\n                a.COBAL,\n                a.CREDLIMITCLATRESAMT,\n                a.RISKRATINGCD,\n                a.NEXTDUEDATE,\n                a.CURRDUEDATE\n            FROM COCCDM.WH_ACCTLOAN a\n            WHERE a.EFFDATE = {effdate_sql}\n        \"\"\")\n\n        wh_acct = text(f\"\"\"\n            SELECT\n                a.ACCTNBR,\n                a.DATEMAT,\n                a.NAICSDESC\n            FROM COCCDM.WH_ACCT a\n            WHERE a.RUNDATE = {effdate_sql}\n        \"\"\")\n        \n        wh_org = text(f\"\"\"\n        SELECT ORGNBR, NAICSCD, NAICSCDDESC AS ORGNAICS, ADDDATE\n        FROM OSIBANK.WH_ORG\n        \"\"\")\n\n        wh_pers = text(f\"\"\"\n        SELECT PERSNBR, NAICSDESC AS PERSNAICS, NAICSCD\n        FROM OSIBANK.WH_PERS\n        \"\"\")\n\n        wh_prop2 = text(f\"\"\"\n        SELECT PROPDESC, ACCTNBR, PROPNBR, EFFDATE, RUNDATE\n        FROM OSIBANK.WH_PROP2\n\n        \"\"\")\n\n        queries = [\n            {'key': 'wh_acctcommon', 'sql': wh_acctcommon, 'engine': 2},\n            {'key': 'wh_loans',      'sql': wh_loans,      'engine': 2},\n            {'key': 'wh_acctloan',   'sql': wh_acctloan,   'engine': 2},\n            {'key': 'wh_acct',       'sql': wh_acct,       'engine': 2},\n            {'key': 'org',     'sql': wh_org,     'engine': 1},\n            {'key': 'pers',    'sql': wh_pers,    'engine': 1},\n            {'key': 'prop2',   'sql': wh_prop2,   'engine': 1}\n        ]\n\n        return cdutils.database.connect.retrieve_data(queries)\n\n\n\n\n\n\n\n\n    data_curr  = fetch_data_for_date(curr_end)\n\n    data_prev  = fetch_data_for_date(prev_end)\n\n\n    def _force_string(df: pd.DataFrame, col: str) -> pd.DataFrame:\n        if col not in df.columns:\n            df[col] = None            # create if missing\n        df[col] = df[col].astype(str).str.strip()\n        return df\n\n\n    # ------------------------------------------------------------------\n    def _transform_snapshot(data_dict: dict) -> pd.DataFrame:\n        # ---------- unpack ----------\n        wh_acctcommon = data_dict[\"wh_acctcommon\"].copy()\n        wh_loans      = data_dict[\"wh_loans\"].copy()\n        wh_acctloan   = data_dict[\"wh_acctloan\"].copy()\n        wh_acct       = data_dict[\"wh_acct\"].copy()\n\n\n        for df in (wh_acctcommon, wh_loans, wh_acctloan, wh_acct):\n            _force_string(df, \"acctnbr\")\n\n        # ---------- joins ----------\n        loans = (\n            wh_acctcommon\n            .merge(wh_acctloan, on=\"acctnbr\", how=\"left\")\n            .merge(wh_loans,      on=\"acctnbr\", how=\"left\")\n            .merge(wh_acct,       on=\"acctnbr\", how=\"left\")\n        )\n\n        # ---------- numeric columns used in the maths ----------\n        num_cols = [\n            \"bookbalance\", \"notebal\",\n            \"availbalamt\", \"totalpctsold\",\n            \"noteopenamt\", \"creditlimitamt\",\n            \"noteintrate\", \"cobal\", \"credlimitclatresamt\",\n        ]\n        for col in num_cols:\n            if col not in loans.columns:\n                loans[col] = 0.0\n            loans[col] = pd.to_numeric(loans[col], errors=\"coerce\")\n            loans[col] = loans[col].fillna(0.0)\n\n        # ---------- exposure mathematica ----------\n        # Tax-exempt bonds (CM45) use NOTEBAL instead of BOOKBALANCE\n        loans[\"bookbalance\"] = np.where(\n            loans[\"currmiaccttypcd\"] == \"CM45\",\n            loans[\"notebal\"],\n            loans[\"bookbalance\"],\n        )\n        loans[\"Net Balance\"]           = loans[\"bookbalance\"] - loans[\"cobal\"]\n        loans[\"Net Available\"]         = loans[\"availbalamt\"] * (1 - loans[\"totalpctsold\"])\n        loans[\"Net Collateral Reserve\"] = (\n            loans[\"credlimitclatresamt\"] * (1 - loans[\"totalpctsold\"])\n        )\n        loans[\"Total Exposure\"] = (\n            loans[\"Net Balance\"] + loans[\"Net Available\"] + loans[\"Net Collateral Reserve\"]\n        )\n\n\n        loans[\"origdate\"] = pd.to_datetime(loans[\"origdate\"], errors=\"coerce\")\n        loans[\"orig_ttl_loan_amt\"] = np.where(\n            loans[\"noteopenamt\"] == 0, loans[\"creditlimitamt\"], loans[\"noteopenamt\"]\n        )\n\n\n        # step 1: redefine fdiccatcd for special cases\n        loans.loc[loans[\"currmiaccttypcd\"].isin([\"CM15\", \"CM16\"]), \"fdiccatcd\"] = \"AUTO\"\n        loans.loc[loans[\"currmiaccttypcd\"].isin([\"CM46\", \"CM47\"]), \"fdiccatcd\"] = \"HOA\"\n        loans.loc[loans[\"currmiaccttypcd\"] == \"CM45\",              \"fdiccatcd\"] = \"OTAL\"\n        loans.loc[loans[\"mjaccttypcd\"] == \"MTG\",                    \"fdiccatcd\"] = \"MTG\"\n        loans.loc[loans[\"currmiaccttypcd\"].isin([\"IL09\", \"IL10\"]), \"fdiccatcd\"] = \"CNOT\"\n        loans[\"fdiccatcd\"] = loans[\"fdiccatcd\"].fillna(\"OTAL\")\n\n        # step 2: final portfolio buckets\n        fdic_groups = {\n            \"CRE\":        [\"CNFM\",\"OTCN\",\"LAND\",\"LNDV\",\"RECN\",\"REFI\",\"REOE\",\"REJU\",\n                        \"REOW\",\"RENO\",\"REMU\",\"OTAL\",\"AGPR\",\"REFM\",\"LENO\"],\n            \"C&I\":        [\"CIUS\"],\n            \"HOA\":        [\"HOA\"],\n            \"Residential\":[\"MTG\"],\n            \"Consumer\":   [\"CNOT\",\"CNCR\"],\n            \"Indirect\":   [\"AUTO\"],\n        }\n        code_to_group = {code: grp for grp, codes in fdic_groups.items() for code in codes}\n        loans[\"Category\"] = loans[\"fdiccatcd\"].map(code_to_group)\n\n\n        loans = loans[loans[\"mjaccttypcd\"].isin([\"CML\", \"MLN\", \"MTG\", \"CNS\"])]\n        loans = loans.sort_values([\"Total Exposure\", \"acctnbr\"], ascending=[False, True])\n        \n        \n        org_df = data_dict.get(\"org\")\n        pers_df = data_dict.get(\"pers\")\n        prop2_df = data_dict.get(\"prop2\")\n\n        if org_df is not None:\n            org_df['adddate'] = pd.to_datetime(org_df['adddate'], errors=\"coerce\")\n            org_df = org_df.loc[org_df.groupby('orgnbr')['adddate'].idxmax()]  # clean_duplicates\n\n        # Rename required columns in main loans df\n        loans.rename(columns={\n            \"taxrptfororgnbr\": \"orgnbr\",\n            \"taxrptforpersnbr\": \"persnbr\"\n        }, inplace=True)\n\n        # Merge in org and pers\n        if org_df is not None:\n            loans = loans.merge(org_df[[\"orgnbr\", \"orgnaics\"]], on=\"orgnbr\", how=\"left\")\n\n        if pers_df is not None:\n            loans = loans.merge(pers_df[[\"persnbr\", \"persnaics\"]], on=\"persnbr\", how=\"left\")\n\n        # Merge in prop2 for MTG loans only\n        if prop2_df is not None:\n            _force_string(prop2_df, \"acctnbr\")\n            loans = loans.merge(prop2_df[[\"acctnbr\", \"propdesc\"]], on=\"acctnbr\", how=\"left\")\n\n        # Final field logic - prioritize wh_acct NAICSDESC for commercial loans\n        # For commercial loans (non-MTG), prioritize NAICSDESC from wh_acct if not null\n        commercial_mask = loans[\"mjaccttypcd\"] != \"MTG\"\n        loans.loc[commercial_mask, \"naicsdesc\"] = loans.loc[commercial_mask, \"naicsdesc\"].combine_first(\n            loans.loc[commercial_mask, \"orgnaics\"].combine_first(loans.loc[commercial_mask, \"persnaics\"])\n        )\n        \n        # For MTG loans, use propdesc as before\n        loans.loc[loans[\"mjaccttypcd\"] == \"MTG\", \"naicsdesc\"] = loans.loc[loans[\"mjaccttypcd\"] == \"MTG\", \"propdesc\"]\n\n        # Final formatting\n        loans[\"officer\"] = loans[\"loanofficer\"].fillna(loans[\"acctofficer\"])\n        # Use currduedate if available, else fallback to nextduedate\n        loans[\"nextpaymentduedate\"] = loans[\"currduedate\"].combine_first(loans[\"nextduedate\"])\n\n        \n        def calculate_non_accrual_and_dpd(loans, curr_end_date):\n            loans[\"curr_end_date\"] = pd.to_datetime(curr_end_date)\n            loans[\"nextpaymentduedate\"] = pd.to_datetime(loans[\"nextpaymentduedate\"], errors='coerce')\n\n            loans[\"nonaccrual\"] = loans[\"curracctstatcd\"].apply(lambda x: 'Yes' if x == 'NPFM' else 'No')\n            loans[\"dpd\"] = (loans[\"curr_end_date\"] - loans[\"nextpaymentduedate\"]).dt.days\n            loans.loc[loans[\"dpd\"] < 0, \"dpd\"] = 0  \n            return loans\n\n        loans = calculate_non_accrual_and_dpd(loans, curr_end)\n\n        return loans\n\n\n    df_prev = _transform_snapshot(data_prev)   # <- prev_end (2025-04-30)\n    df_curr = _transform_snapshot(data_curr)   # <- curr_end (2025-03-28)\n\n\n    # --- Raw input copies\n\n    df_prev_raw = df_prev\n    df_curr_raw = df_curr\n\n    # --- Collapse to latest effdate per acctnbr\n    def collapse_to_latest(df):\n        df = df.copy()\n        df['effdate'] = pd.to_datetime(df['effdate'])\n        df = df.sort_values(['acctnbr', 'effdate'], ascending=[True, False])\n        return df.drop_duplicates('acctnbr', keep='first')\n\n    df_prev = collapse_to_latest(df_prev_raw)\n    df_curr = collapse_to_latest(df_curr_raw)\n\n    # --- Categories\n    cats = {\n        \"4-CML\": (\"CML\", \"4\"),\n        \"5-CML\": (\"CML\", \"5\"),\n        \"5-MTG\": (\"MTG\", \"5\"),\n    }\n\n    # --- Column mapping\n    column_mapping = {\n        \"product\": \"Product Name\",\n        \"officer\": \"Responsibility Officer\",\n        \"riskratingcd\": \"Risk Rating\",\n        \"ownersortname\": \"Customer Name\",\n        \"acctnbr\": \"Account\\nNumber\",\n        \"mjaccttypcd\": \"Major\",\n        \"notebal\": \"Current\\nBalance\",\n        \"cobal\": \"Charge\\nOff\",\n        \"Net Balance\": \"Net\\nBalance\",\n        #\"notebal\": \"Current Note Balance\",\n        \"nonaccrual\": \"Non\\nAccrual\",\n        \"dpd\": \"Days Past\\nDue\",\n        \"nextpaymentduedate\": \"Next\\nPayment\\nDue Date\",\n        \"naicsdesc\": \"NAICS Description\",\n        \"effdate\": \"EFFDATE\",\n        \n    }\n\n    def format_for_export(df):\n        out = pd.DataFrame()\n        for raw, nice in column_mapping.items():\n            out[nice] = df[raw] if raw in df.columns else \"\"\n        return out\n\n    # --- Reconciliation builder\n    def build_reconciliation(prev_df, curr_df, cat_label):\n        p = prev_df.copy()\n        c = curr_df.copy()\n        full_curr = df_curr.copy()\n        rows = []\n\n        start_bal = p[\"Net Balance\"].sum()\n        end_bal = c[\"Net Balance\"].sum()\n        start_date = p[\"effdate\"].iloc[0].strftime(\"%m/%d/%Y\") if not p.empty else \"N/A\"\n        end_date = c[\"effdate\"].iloc[0].strftime(\"%m/%d/%Y\") if not c.empty else \"N/A\"\n\n        prev_rr = cat_label.split(\"-\")[0]\n\n        rows.append([f\"CML Grade {prev_rr}\" if \"CML\" in cat_label else cat_label, \"Customer Name\", \"Current RR\", \"$\", \"#\"])\n        rows.append([start_date, \"\", \"\", round(start_bal, 2), len(p)])\n\n        # Helper to group by customer\n        def group_by_customer(df, name_col, amt_col):\n            grouped = df.groupby(name_col).agg(\n                {amt_col: \"sum\", \"acctnbr\": \"count\"}\n            ).reset_index()\n            return grouped\n\n        # New Loans\n        new_loans = c[~c[\"acctnbr\"].isin(p[\"acctnbr\"])]\n        if not new_loans.empty:\n            rows.append([f\"New Grade {prev_rr}\", \"\", \"\", \"\", \"\"])\n            grouped = group_by_customer(new_loans, \"ownersortname\", \"Net Balance\")\n            for _, r in grouped.iterrows():\n                rows.append([\"\", r[\"ownersortname\"], \"\", r[\"Net Balance\"], r[\"acctnbr\"]])\n\n        # Risk Rating Change\n        p_matched = p[p[\"acctnbr\"].isin(full_curr[\"acctnbr\"])]\n        joined = pd.merge(p_matched, full_curr, on=\"acctnbr\", suffixes=(\"_p\", \"_c\"))\n        rr_change = joined[(joined[\"riskratingcd_p\"] == prev_rr) & (joined[\"riskratingcd_c\"] != prev_rr)]\n        if not rr_change.empty:\n            rows.append([f\"Risk Rating Change (Previously Rated {prev_rr})\", \"\", \"\", \"\", \"\"])\n            grouped = rr_change.groupby(\"ownersortname_c\").agg(\n                {\"Net Balance_p\": \"sum\", \"acctnbr\": \"count\", \"riskratingcd_c\": \"first\"}\n            ).reset_index()\n            for _, r in grouped.iterrows():\n                rows.append([\"\", r[\"ownersortname_c\"], r[\"riskratingcd_c\"], -r[\"Net Balance_p\"], r[\"acctnbr\"]])\n\n        # Paid to Zero Balance (fixed condition)\n        zeroed = joined[(joined[\"Net Balance_c\"] == 0) & (joined[\"Net Balance_p\"] != 0)]\n        if not zeroed.empty:\n            rows.append([\"Paid to a Zero Balance\", \"\", \"\", \"\", \"\"])\n            grouped = zeroed.groupby(\"ownersortname_c\").agg(\n                {\"Net Balance_p\": \"sum\", \"acctnbr\": \"count\", \"riskratingcd_c\": \"first\"}\n            ).reset_index()\n            for _, r in grouped.iterrows():\n                rows.append([\"\", r[\"ownersortname_c\"], r[\"riskratingcd_c\"], -r[\"Net Balance_p\"], r[\"acctnbr\"]])\n\n        # LOC Advance\n        loc = joined[joined[\"Net Balance_c\"] > joined[\"Net Balance_p\"]]\n        if not loc.empty:\n            rows.append([\"LOC Advance\", \"\", \"\", \"\", \"\"])\n            grouped = loc.groupby(\"ownersortname_c\").agg(\n                {\"Net Balance_c\": \"sum\", \"Net Balance_p\": \"sum\", \"acctnbr\": \"count\", \"riskratingcd_c\": \"first\"}\n            ).reset_index()\n            grouped[\"delta\"] = grouped[\"Net Balance_c\"] - grouped[\"Net Balance_p\"]\n            for _, r in grouped.iterrows():\n                rows.append([\"\", r[\"ownersortname_c\"], r[\"riskratingcd_c\"], r[\"delta\"], r[\"acctnbr\"]])\n\n        # Paid Off / Charged Off\n        paid_off = p[~p[\"acctnbr\"].isin(full_curr[\"acctnbr\"])]\n        if not paid_off.empty:\n            rows.append([\"Paid Off/Charged Off Loans\", \"\", \"\", \"\", \"\"])\n            grouped = group_by_customer(paid_off, \"ownersortname\", \"Net Balance\")\n            for _, r in grouped.iterrows():\n                rows.append([\"\", r[\"ownersortname\"], \"\", -r[\"Net Balance\"], r[\"acctnbr\"]])\n\n        # Partial Charge Offs\n        partial = joined[joined[\"cobal_c\"] > joined[\"cobal_p\"]]\n        if not partial.empty:\n            rows.append([\"Partial Charge Offs\", \"\", \"\", \"\", \"\"])\n            grouped = partial.groupby(\"ownersortname_c\").agg(\n                {\"cobal_c\": \"sum\", \"cobal_p\": \"sum\", \"acctnbr\": \"count\", \"riskratingcd_c\": \"first\"}\n            ).reset_index()\n            grouped[\"delta\"] = -(grouped[\"cobal_c\"] - grouped[\"cobal_p\"])\n            for _, r in grouped.iterrows():\n                rows.append([\"\", r[\"ownersortname_c\"], r[\"riskratingcd_c\"], r[\"delta\"], r[\"acctnbr\"]])\n\n        # --- Net Payments & Advances ---\n        # Calculate sum of all other reconciliation items (excluding start/end balances and net adjustments)\n        sum_other = 0\n        for row in rows[2:]:  # skip header and start balance\n            try:\n                amt = float(row[3])\n                sum_other += amt\n            except Exception:\n                continue\n\n        net_adj = end_bal - start_bal\n        net_payments_advances = net_adj - sum_other\n\n        rows.append([\"Net Payments & Advances\", \"\", \"\", net_payments_advances, \"\"])\n        rows.append([\"Net Adjustments\", \"\", \"\", net_adj, \"\"])\n        rows.append([end_date, \"\", \"\", round(end_bal, 2), len(c)])\n\n        return pd.DataFrame(rows)\n\n\n\n    bold_font   = Font(bold=True)\n    title_font  = Font(bold=True, size=16)\n\n    thin_side   = Side(style=\"thin\")\n    dbl_side    = Side(style=\"double\")\n\n    def make_border(top=False, bottom=False, left=False, right=False, double_bottom=False) -> Border:\n        \"\"\"Return a Border with requested edges.\"\"\"\n        return Border(\n            top    = thin_side if top else None,\n            bottom = (dbl_side if double_bottom else thin_side) if bottom else None,\n            left   = thin_side if left else None,\n            right  = thin_side if right else None,\n        )\n\n    # ========================== WRITE  ==========================\n    def write_out_excel():\n        with pd.ExcelWriter(output_path, engine=\"openpyxl\") as writer:\n            ws_title, startrow = \"Loan Report\", 1\n\n            # Static page header\n            pd.DataFrame(\n                [\n                    [\"BRISTOL COUNTY SAVINGS BANK\"],\n                    [\"MONTHLY CLASSIFIED LOANS LIST\"],\n                    [f\"DATE {curr_end}\"],\n                    [],\n                    [\"RECONCILIATION\"],\n                ]\n            ).to_excel(writer, sheet_name= ws_title, index=False, header=False, startrow=startrow-1, startcol=1)\n            startrow += 5\n\n            recon_title_rows, recon_boxes = [], []\n            summary_title_rows, header_rows, totals_rows = [], [], []\n\n            # --------------------- 1. RECONCILIATION BOXES ---------------------\n            for label, (maj, rr) in cats.items():\n                # Include MLN loans with risk rating 4 in Grade 4 Commercial\n                if label == \"4-CML\":\n                    prev_cat = df_prev[((df_prev[\"mjaccttypcd\"]==maj) | \n                                       ((df_prev[\"mjaccttypcd\"]==\"MLN\") & (df_prev[\"riskratingcd\"]==rr))) & \n                                      (df_prev[\"riskratingcd\"]==rr)]\n                    curr_cat = df_curr[((df_curr[\"mjaccttypcd\"]==maj) | \n                                       ((df_curr[\"mjaccttypcd\"]==\"MLN\") & (df_curr[\"riskratingcd\"]==rr))) & \n                                      (df_curr[\"riskratingcd\"]==rr)]\n                else:\n                    prev_cat = df_prev[(df_prev[\"mjaccttypcd\"]==maj)&(df_prev[\"riskratingcd\"]==rr)]\n                    curr_cat = df_curr[(df_curr[\"mjaccttypcd\"]==maj)&(df_curr[\"riskratingcd\"]==rr)]\n                \n                if prev_cat.empty and curr_cat.empty:\n                    continue\n\n                prev_date = prev_cat[\"effdate\"].iloc[0].strftime(\"%m/%d/%Y\") if not prev_cat.empty else \"N/A\"\n                curr_date = curr_cat[\"effdate\"].iloc[0].strftime(\"%m/%d/%Y\") if not curr_cat.empty else \"N/A\"\n\n                # Title row outside border\n                pd.DataFrame([[f\"Grade {rr} Loans ({'Commercial' if maj!='MTG' else 'Residential'})\", \"\", \"$\", \"#\"]]) \\\n                    .to_excel(writer, sheet_name= ws_title, index=False, header=False, startrow=startrow, startcol=1)\n                recon_title_rows.append(startrow+1)\n                startrow += 1\n\n                # Build reconciliation rows\n                rows = [[prev_date, \"\", prev_cat[\"Net Balance\"].sum(), len(prev_cat)]]\n                reco = build_reconciliation(prev_cat, curr_cat, label)\n                BAD  = {\"customer name\",\"current rr\",\"cml grade 4\",\"cml grade 5\",\n                        \"mtg grade 5\",\"substandard\",\"special mention\"}\n                reco = reco[~reco[0].str.lower().fillna(\"\").isin(BAD)]\n                blank = lambda v: pd.isna(v) or str(v).strip()==\"\"\n                for _, r in reco.iterrows():\n                    lbl, name, *_ , amt, cnt = r.tolist()\n                    if lbl and blank(name) and blank(amt):\n                        rows.append([lbl,\"\",\"\",\"\"])\n                    elif str(lbl).lower().startswith(\"net\"):\n                        rows.append([lbl,\"\",amt,\"\"])\n                    elif name and isinstance(amt,(int,float)):\n                        rows.append([\"\",name,amt,cnt])\n                rows.append([f\"{curr_date} Balance\", \"\", curr_cat[\"Net Balance\"].sum(), len(curr_cat)])\n\n                pd.DataFrame(rows).to_excel(writer, sheet_name= ws_title, index=False, header=False,\n                                            startrow=startrow, startcol=1)\n                recon_boxes.append((startrow+1, startrow+len(rows), 2, 5))   # full border extents\n                startrow += len(rows)+2\n\n            # --------------------- 2. SUMMARY SECTIONS ---------------------\n            TITLES = {\"4-CML\": \"4 - Special Mention Commercial\",\n                    \"5-CML\": \"5 - Substandard Commercial\",\n                    \"5-MTG\": \"5 - Substandard Residential\"}\n\n            for label, (maj, rr) in cats.items():\n                # Include MLN loans with risk rating 4 in Grade 4 Commercial\n                if label == \"4-CML\":\n                    df = format_for_export(df_curr[((df_curr[\"mjaccttypcd\"]==maj) | \n                                                   ((df_curr[\"mjaccttypcd\"]==\"MLN\") & (df_curr[\"riskratingcd\"]==rr))) & \n                                                  (df_curr[\"riskratingcd\"]==rr)])\n                else:\n                    df = format_for_export(df_curr[(df_curr[\"mjaccttypcd\"]==maj)&(df_curr[\"riskratingcd\"]==rr)])\n                \n                if df.empty: continue\n                if label==\"5-MTG\":\n                    df.rename(columns={\"NAICS Description\":\"PROPERTY ADDRESS\"}, inplace=True)\n\n                df.drop(columns=[\"Risk Rating\",\"Major\"], errors=\"ignore\", inplace=True)\n\n                # Account Number numeric\n                if \"acctnbr\" in df.columns:\n                    df[\"acctnbr\"] = pd.to_numeric(df[\"acctnbr\"], errors=\"coerce\")\n                    df[\"acctnbr\"] = df[\"acctnbr\"].astype(\"Int64\")\n\n                # Sort\n                dpd_col = next((c for c in df.columns if c.replace(\"\\n\",\" \").strip().lower()==\"days past due\"), None)\n                df.sort_values([\"Customer Name\"]+([dpd_col] if dpd_col else []),\n                            ascending=[True,False] if dpd_col else [True], inplace=True)\n\n                # Date fix\n                for col in df.columns:\n                    if \"next\" in col.lower() and \"due\" in col.lower():\n                        df[col] = pd.to_datetime(df[col]).dt.date\n\n                # Title row\n                pd.DataFrame([[TITLES[label]]]).to_excel(writer, sheet_name= ws_title, index=False, header=False,\n                                                        startrow=startrow, startcol=0)\n                summary_title_rows.append(startrow+1)\n                startrow+=1\n\n                # Header row\n                pd.DataFrame([df.columns]).to_excel(writer, sheet_name= ws_title, index=False, header=False,\n                                                    startrow=startrow, startcol=0)\n                header_rows.append((startrow+1, len(df.columns)))\n                startrow+=1\n\n                # Data\n                df.to_excel(writer, sheet_name= ws_title, index=False, header=False,\n                            startrow=startrow, startcol=0, na_rep=\"\")\n                startrow+=len(df)\n\n                # Totals row (numeric sums only)\n                totals=[]\n                for col in df.columns:\n                    norm = col.replace(\"\\n\",\" \").strip().lower()\n                    if norm==\"customer name\": totals.append(\"\")\n                    elif norm==\"days past due\": totals.append(\"\")\n                    elif pd.api.types.is_numeric_dtype(df[col]):\n                        totals.append(df[col].sum())\n                    else:\n                        totals.append(\"\")\n                pd.DataFrame([totals], columns=df.columns).to_excel(writer, sheet_name= ws_title, index=False,\n                                                                    header=False, startrow=startrow, startcol=0)\n                totals_rows.append(startrow+1)\n                startrow += 2\n\n        # ===================================================================\n        #                        OPENPYXL FORMATTING\n        # ===================================================================\n        wb = load_workbook(output_path)\n        ws = wb[\"Loan Report\"]\n\n        # Static header bold\n        for rr in (1,2,3,4,6): ws[f\"B{rr}\"].font = bold_font\n        for rr in (5,6) : ws[f\"B{rr}\"].font = bold_font\n        # Recon titles bold\n        for rr in recon_title_rows:\n            for cc in range(2,6): ws.cell(rr,cc).font=Font(bold=True,italic=True)\n\n        # Recon boxes with full borders\n        for top,bot,l,r in recon_boxes:\n            for rr in range(top,bot+1):\n                ws.cell(rr,l).font = bold_font\n                if isinstance(ws.cell(rr,4).value,(int,float)):\n                    ws.cell(rr,4).number_format='$#,##0.00;($#,##0.00)'\n            for rr in range(top,bot+1):\n                for cc in range(l,r+1):\n                    ws.cell(rr,cc).border = make_border(\n                        top=(rr==top or (rr==bot and cc in (4,5))),\n                        bottom=(rr==bot),\n                        left=(cc==l),\n                        right=(cc==r)\n                    )\n\n        # Summary titles big & bold\n        for rr in summary_title_rows:\n            ws.cell(rr,1).font = title_font\n\n        # Summary headers boxed & centered\n        for rr,ncols in header_rows:\n            hdr_map = {ws.cell(rr,c).value:c for c in range(1,ncols+1)}\n            for c in range(1,ncols+1):\n                h=ws.cell(rr,c)\n                h.font=bold_font\n                h.alignment = Alignment(wrap_text=True,horizontal='center',vertical='center')\n                h.border = make_border(top=True,bottom=True,left=True,right=True)\n\n            acct = hdr_map.get(\"Account\\nNumber\")\n            curr = hdr_map.get(\"Current\\nBalance\")\n            chg  = hdr_map.get(\"Charge\\nOff\")\n            net  = hdr_map.get(\"Net\\nBalance\")\n            dpd  = hdr_map.get(\"Days Past\\nDue\")\n            non  = hdr_map.get(\"Non\\nAccrual\")\n            nxt  = hdr_map.get(\"Next\\nPayment\\nDue Date\")\n\n            # Find totals row\n            r0=rr+1\n            while ws.cell(r0,1).value not in (None,\"\",\"Total Loans:\", \"Total Loans\"): r0+=1\n            last=r0-1; tot=r0\n\n            # Numeric formatting\n            if acct:\n                for row in range(rr+1,last+1):\n                    c=ws.cell(row,acct)\n                    if isinstance(c.value,str) and c.value.isdigit():\n                        c.value=int(c.value)\n                    c.number_format='0'\n\n            for col in (curr,chg,net):\n                if col:\n                    for row in range(rr+1,last+1):\n                        cv=ws.cell(row,col)\n                        if isinstance(cv.value,(int,float)):\n                            cv.number_format='#,##0.00'\n\n            # Place Total Loans in D, sums already in E/F/G\n            if curr:\n                ws.cell(tot, curr-1, f\"Total Loans: {last-rr}\")\n\n            # Center alignment\n            center = Alignment(horizontal='center',vertical='center')\n            if dpd:\n                for row in range(rr+1,last+1): ws.cell(row,dpd).alignment=center\n            if non:\n                for row in range(rr+1,last+1): ws.cell(row,non).alignment=center\n            if nxt:\n                for row in range(rr+1,last+1):\n                    cell=ws.cell(row,nxt)\n                    if isinstance(cell.value,pd.Timestamp): cell.value=cell.value.date()\n                    if isinstance(cell.value,(datetime,date)):\n                        cell.number_format='mm/dd/yyyy'\n\n        # Totals rows: bold, thin top, double bottom (no L/R)\n        for t in totals_rows:\n            for col in (4,5,6,7):       # D,E,F,G\n                c=ws.cell(t,col)\n                c.font=bold_font\n                c.border = make_border(top=True,bottom=True,double_bottom=True)\n\n            # Currency formatting for sums\n            for col in (5,6,7):         # E,F,G\n                if isinstance(ws.cell(t,col).value,(int,float)):\n                    ws.cell(t,col).number_format='#,##0.00'\n\n        # Column widths with caps & minimums\n        CAPS = {\"Next\\nPayment\\nDue Date\":12, \"Responsibility Officer\":28,\n                \"Account\\nNumber\":15, \"Current\\nBalance\":15,\n                \"Charge\\nOff\":15, \"Net\\nBalance\":15}\n\n        header_lookup={}\n        for rr,_ in header_rows:\n            for cc in range(1,ws.max_column+1):\n                if (val:=ws.cell(rr,cc).value) and cc not in header_lookup:\n                    header_lookup[cc]=val\n\n        for col in ws.columns:\n            idx=col[0].column\n            hdr=header_lookup.get(idx,\"\")\n            cap=CAPS.get(hdr)\n            longest,numeric_only,num_len = 0,True,0\n            for cell in col:\n                txt=str(cell.value or \"\")\n                longest=max(longest,*[len(x) for x in txt.split(\"\\n\")])\n                if isinstance(cell.value,(int,float)):\n                    num_len=max(num_len,len(txt))\n                else:\n                    numeric_only=False\n            width=(num_len+1) if numeric_only else (longest+2)\n            if hdr in {\"Current\\nBalance\",\"Charge\\nOff\",\"Net\\nBalance\"}:\n                width=max(width,15)\n            if cap: width=min(width,cap) if not numeric_only else max(width,cap)\n            ws.column_dimensions[get_column_letter(idx)].width = width\n\n        wb.save(output_path)\n    \n    write_out_excel()\n\n\nif __name__ == \"__main__\":\n    print(f\"Starting version: {__version__}\")\n    main()\n    print(\"Complete!\")\n",
          "text(",
          "text(",
          "text(",
          "text(",
          "text(",
          "text(",
          "text("
        ],
        "output_patterns": [
          ".to_excel(writer, sheet_name= ws_title, index=False, header=False, startrow=startrow-1, startcol=1)",
          ".to_excel(writer, sheet_name= ws_title, index=False, header=False, startrow=startrow, startcol=1)",
          ".to_excel(writer, sheet_name= ws_title, index=False, header=False,\n                                            startrow=startrow, startcol=1)",
          ".to_excel(writer, sheet_name= ws_title, index=False, header=False,\n                                                        startrow=startrow, startcol=0)",
          ".to_excel(writer, sheet_name= ws_title, index=False, header=False,\n                                                    startrow=startrow, startcol=0)",
          ".to_excel(writer, sheet_name= ws_title, index=False, header=False,\n                            startrow=startrow, startcol=0, na_rep=\"\")",
          ".to_excel(writer, sheet_name= ws_title, index=False,\n                                                                    header=False, startrow=startrow, startcol=0)",
          "OUTPUT_PATH: Path = BASE_PATH / Path('./Output')",
          "output_path = OUTPUT_PATH / f\"{curr_end_xlsx}\"",
          "output_path, engine=\"openpyxl\") as writer:",
          "OUTPUT_PATH: Path = BASE_PATH / Path",
          "output_path = OUTPUT_PATH",
          ".save(",
          "ExcelWriter"
        ],
        "email_patterns": [],
        "path_patterns": [
          "r'\\\\00-DA1\\Home\\Share\\Data & Analytics Initiatives\\Project Management\\Credit_Loan_Review\\Resolution Committee Automation\\Classifieds\\Production'",
          "Path(r'\\\\00-DA1\\Home\\Share\\Data & Analytics Initiatives\\Project Management\\Credit_Loan_Review\\Resolution Committee Automation\\Classifieds\\Production')",
          "Path('.')",
          "Path('./Output')",
          "BASE_PATH =",
          "BASE_PATH =",
          "PRODUCTION_FLAG",
          "production_flag",
          "production_flag"
        ],
        "version": ")\n    else:\n        BASE_PATH = Path(",
        "functions": [
          "main"
        ],
        "schedule_hints": [
          "monthly"
        ],
        "data_sources": [
          "COCC",
          "Oracle",
          "WH_",
          "ACCT",
          "LOAN"
        ],
        "file_operations": [
          "load_workbook"
        ]
      },
      "fetch_data": {}
    }
  },
  {
    "report_id": "Resolution Committee Automation/Non Accruals",
    "name": "Non Accruals",
    "business_line": "Resolution Committee Automation",
    "purpose": "Non Accrual Report\n\nThis is an item for the Resolution Committee Package. This increases\noperational efficiency by automating a task done by the Loan Review team.\n\nThis report tracks all non-performing loans &amp; reconciles month over month\nchanges.",
    "frequency": "manual",
    "has_email": true,
    "data_sources": [
      "sqlalchemy",
      "COCCDM"
    ],
    "version": ")\n    else:\n        BASE_PATH = Path(",
    "functions": [
      "main"
    ],
    "needs_config": true,
    "analysis": {
      "main": {
        "docstring": "Non Accrual Report\n\nThis is an item for the Resolution Committee Package. This increases\noperational efficiency by automating a task done by the Loan Review team.\n\nThis report tracks all non-performing loans &amp; reconciles month over month\nchanges.",
        "imports": [
          "from pathlib",
          "import pandas",
          "import numpy",
          "import src.fetch_data",
          "import src.fetch_subsequent_data",
          "import src.export_and_format",
          "import src.main_pipeline",
          "import cdutils.loans.calculations",
          "from src._version"
        ],
        "database_queries": [],
        "output_patterns": [
          ".to_excel(writer, sheet_name=sheet_name, index=False)",
          "OUTPUT_PATH = BASE_PATH / Path(output_string)",
          "OUTPUT_PATH, engine='xlsxwriter', datetime_format='mm/dd/yyyy') as writer:",
          "OUTPUT_PATH = BASE_PATH / Path",
          "ExcelWriter"
        ],
        "email_patterns": [
          "email_out(",
          "distribution.",
          "@bcsbmail.com",
          "@bcsbmail.com",
          "@bcsbmail.com",
          "@bcsbmail.com",
          "recipients =",
          "recipients ="
        ],
        "path_patterns": [
          "r'\\\\00-DA1\\Home\\Share\\\\Data & Analytics Initiatives\\\\Project Management\\\\Credit_Loan_Review\\\\Acct_Attorney_Consultant_Report\\\\Production'",
          "Path(r'\\\\00-DA1\\Home\\Share\\\\Data & Analytics Initiatives\\\\Project Management\\\\Credit_Loan_Review\\\\Acct_Attorney_Consultant_Report\\\\Production')",
          "Path('.')",
          "Path(output_string)",
          "BASE_PATH =",
          "BASE_PATH =",
          "production_flag",
          "production_flag",
          "production_flag"
        ],
        "version": ")\n    else:\n        BASE_PATH = Path(",
        "functions": [
          "main"
        ],
        "schedule_hints": [],
        "data_sources": [],
        "file_operations": [
          "glob"
        ]
      },
      "fetch_data": {
        "queries": [
          "text(f\"\"\"\n    SELECT \n        ANY_VALUE(ACCTNBR)"
        ],
        "tables": [
          "sqlalchemy",
          "COCCDM"
        ],
        "databases": []
      }
    }
  },
  {
    "report_id": "Indirect_Lending/EContracts",
    "name": "EContracts",
    "business_line": "Indirect_Lending",
    "purpose": "Unknown",
    "frequency": "daily",
    "has_email": false,
    "data_sources": [],
    "version": ")\n    main(production_flag=True)\n    # process_daily()\n    print(",
    "functions": [
      "main"
    ],
    "needs_config": true,
    "analysis": {
      "main": {
        "docstring": null,
        "imports": [
          "import pandas",
          "from datetime",
          "import os",
          "import re",
          "import win32com.client",
          "from pathlib",
          "from dateutil.relativedelta",
          "from src._version",
          "import src.grabData",
          "import src.buildReport",
          "import src.exportReport"
        ],
        "database_queries": [],
        "output_patterns": [],
        "email_patterns": [],
        "path_patterns": [
          "production_flag",
          "production_flag",
          "production_flag",
          "production_flag"
        ],
        "version": ")\n    main(production_flag=True)\n    # process_daily()\n    print(",
        "functions": [
          "main"
        ],
        "schedule_hints": [
          "daily"
        ],
        "data_sources": [],
        "file_operations": []
      },
      "fetch_data": {}
    }
  },
  {
    "report_id": "Indirect_Lending/Monthly Goal Report",
    "name": "Monthly Goal Report",
    "business_line": "Indirect_Lending",
    "purpose": "Unknown",
    "frequency": "daily",
    "has_email": false,
    "data_sources": [],
    "version": ")\n    main(production_flag=True)\n    # process_daily()\n    print(",
    "functions": [
      "main"
    ],
    "needs_config": true,
    "analysis": {
      "main": {
        "docstring": null,
        "imports": [
          "import pandas",
          "from datetime",
          "import os",
          "import re",
          "from pathlib",
          "from src._version",
          "import src.format_excel_file"
        ],
        "database_queries": [],
        "output_patterns": [
          ".to_excel(output_path, index='False')",
          "output_path = Path(r\"\\\\00-da1\\Home\\Share\\Line of Business_Shared Services\\Indirect Lending\\Monthly Goal Report\\Production\\Output\") / Path(\"Monthly Goal Report \" + previous_month + \" \" + str(year_of_previous_month) + \".xlsx\")",
          "output_path = Path(r\"\\\\00-da1\\Home\\Share\\Data & Analytics Initiatives\\Project Management\\Indirect_Lending\\Monthly Goal Report\\Production\\Output\") / Path(\"Monthly Goal Report \" + previous_month + \" \" + str(year_of_previous_month) + \".xlsx\")",
          "output_path, index='False')",
          "output_path = Path(r\"\\\\00-da1\\Home\\Share\\Line of Business_Shared Services\\Indirect Lending\\Monthly Goal Report\\Production\\Output\") / Path",
          "output_path = Path(r\"\\\\00-da1\\Home\\Share\\Data & Analytics Initiatives\\Project Management\\Indirect_Lending\\Monthly Goal Report\\Production\\Output\") / Path"
        ],
        "email_patterns": [],
        "path_patterns": [
          "r\"\\\\00-da1\\Home\\Share\\Line of Business_Shared Services\\Indirect Lending\\E Contract Summary Report\\Production\\Input\"",
          "r\"\\\\00-da1\\Home\\Share\\Line of Business_Shared Services\\Indirect Lending\\Monthly Goal Report\\Production\\Output\"",
          "r\"\\\\00-da1\\Home\\Share\\Data & Analytics Initiatives\\Project Management\\Indirect_Lending\\Monthly Goal Report\\Production\\Input\"",
          "r\"\\\\00-da1\\Home\\Share\\Data & Analytics Initiatives\\Project Management\\Indirect_Lending\\Monthly Goal Report\\Production\\Output\"",
          "Path(r\"\\\\00-da1\\Home\\Share\\Line of Business_Shared Services\\Indirect Lending\\Monthly Goal Report\\Production\\Output\")",
          "Path(\"Monthly Goal Report \" + previous_month + \" \" + str(year_of_previous_month)",
          "Path(r\"\\\\00-da1\\Home\\Share\\Data & Analytics Initiatives\\Project Management\\Indirect_Lending\\Monthly Goal Report\\Production\\Output\")",
          "Path(\"Monthly Goal Report \" + previous_month + \" \" + str(year_of_previous_month)",
          "production_flag",
          "production_flag",
          "production_flag"
        ],
        "version": ")\n    main(production_flag=True)\n    # process_daily()\n    print(",
        "functions": [
          "main"
        ],
        "schedule_hints": [
          "daily",
          "monthly"
        ],
        "data_sources": [],
        "file_operations": [
          "listdir"
        ]
      },
      "fetch_data": {}
    }
  },
  {
    "report_id": "Indirect_Lending/Dealer Track - Route One Reconciliaton",
    "name": "Dealer Track - Route One Reconciliaton",
    "business_line": "Indirect_Lending",
    "purpose": "Unknown",
    "frequency": "daily",
    "has_email": false,
    "data_sources": [],
    "version": ")\n        BASE_PATH = Path(r",
    "functions": [
      "process_report"
    ],
    "needs_config": true,
    "analysis": {
      "main": {
        "docstring": null,
        "imports": [
          "import os",
          "from pathlib",
          "import pandas",
          "import re",
          "import warnings",
          "from openpyxl",
          "from openpyxl.utils",
          "from openpyxl",
          "from shutil",
          "from datetime"
        ],
        "database_queries": [],
        "output_patterns": [
          "OUTPUT_PATH: Path = BASE_PATH / Path('./Reports')",
          "output_path = OUTPUT_PATH / f\"{month_year} DL Reconciliation Report.xlsx\"",
          "OUTPUT_PATH: Path = BASE_PATH / Path",
          "output_path = OUTPUT_PATH",
          "output_excel_file = output_path",
          ".save(",
          ".save(",
          "ExcelWriter"
        ],
        "email_patterns": [],
        "path_patterns": [
          "r'\\\\00-DA1\\Home\\Share\\Line of Business_Shared Services\\Indirect Lending\\DealerTrack-RouteOne Recon\\Production'",
          "Path(r'\\\\00-DA1\\Home\\Share\\Line of Business_Shared Services\\Indirect Lending\\DealerTrack-RouteOne Recon\\Production')",
          "Path(r'U:\\Project Management\\Indirect_Lending\\Dealer Track - Route One Reconciliaton')",
          "Path('./Input')",
          "Path('./Reports')",
          "Path('./Archive')",
          "BASE_PATH =",
          "BASE_PATH =",
          "PRODUCTION_FLAG",
          "production_flag",
          "production_flag",
          "production_flag"
        ],
        "version": ")\n        BASE_PATH = Path(r",
        "functions": [
          "process_report"
        ],
        "schedule_hints": [
          "daily"
        ],
        "data_sources": [],
        "file_operations": [
          "read_excel",
          "load_workbook",
          "listdir"
        ]
      },
      "fetch_data": {}
    }
  }
]